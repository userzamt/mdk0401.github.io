# Урок 14. Регулярные выражения

[На главную](/mdk0401.github.io)

**Выражение** - это строка символов. Символы, которые имеют особое назначение, называются **метасимволами**. Так, например, кавычки могут выделять прямую речь, т.е. быть метасимволами для строки, заключенной в эти кавычки. 

**Регулярные выражения** - это набор символов и/или метасимволов, которые наделены особыми свойствами. Основное назначение регулярных выражений - это поиск текста по шаблону и работа со строками.

**Регулярные выражения** — это специальным образом записанные строки, используемые для поиска символьных шаблонов в тексте. 

Многие утилиты для работы с текстом в Linux и языки программирования включают в себя механизм регулярных выражений. Здесь возникают проблемы: разные программы и языки оперируют различными диалектами регулярных выражений. 

## Типы регулярных выражений
Реализации регулярных выражений в различных средах, например, в языках программирования вроде Java, Perl и Python, в инструментах Linux вроде `sed`, `awk` и `grep`, имеют определённые особенности. Эти особенности зависят от так называемых движков обработки регулярных выражений, которые занимаются интерпретацией шаблонов.

В Linux имеется два движка регулярных выражений:

+ Движок, поддерживающий стандарт **POSIX Basic Regular Expression (BRE)**.
+ Движок, поддерживающий стандарт **POSIX Extended Regular Expression (ERE)**.

Большинство утилит Linux соответствуют, как минимум, стандарту POSIX BRE, но некоторые утилиты (в их числе — sed) понимают лишь некое подмножество стандарта BRE. Одна из причин такого ограничения — стремление сделать такие утилиты как можно более быстрыми в деле обработки текстов.

Стандарт POSIX ERE часто реализуют в языках программирования. Он позволяет пользоваться большим количеством средств при разработке регулярных выражений. Например, это могут быть специальные последовательности символов для часто используемых шаблонов, вроде поиска в тексте отдельных слов или наборов цифр. Awk поддерживает стандарт ERE.

## `grep`
`grep`(global / regular expression search / and print) — это основной инструмент для работы с регулярными выражениями. 

`grep` анализирует данные со стандартного ввода, ищет совпадения с указанным шаблоном и выводит все подходящие строки. 

> [!NOTE]
> Обычно `grep` предустановлен в большинстве дистрибутивов. 

`grep` имеет следующий синтаксис:

```
grep [параметры] регулярное_выражение [файл…]
```

Самый простой случай использования `grep` — поиск строк, содержащих фиксированную подстроку.

```bash
grep '2018' --color supplier_k_import.csv
```

У `grep` имеются множество параметров. Подробно с ними ознакомиться можно в документации. Ниже приведены ключи, полезные при работе с регулярными выражениями

+ `-v` — инвертировать критерий. В этом случае grep выводит строки, не содержащие совпадений

```bash
grep -v 'ООО' supplier_k_import.csv
```

+ `-i` — игнорировать регистр символов

```bash
grep -i 'тел' --color supplier_k_import.csv
```

+ `-o` — выводить не строки, а только совпадения с шаблоном

```bash
grep -o 'ООО' --color supplier_k_import.csv

grep -o 'ООО' --color supplier_k_import.csv | wc
```

+ `-n` - вывод номера сроки при совпадении с шаблоном

```bash
grep -in --color "gnu" gnugpl.txt
```

+ `-E` - интерпретирует шаблон как расширенное регулярное выражение (ERE)

## Специальные символы
При использовании различных символов в регулярных выражениях надо учитывать некоторые особенности. Так, существуют некоторые специальные символы, или метасимволы, использование которых в шаблоне требует особого подхода. 

```
.*[]^${}\+?|()
```

Если один из них нужен в шаблоне, его нужно будет экранировать с помощью обратной косой черты (обратного слэша) — `\`.

```bash
grep  '.' --color gnugpl.txt

grep  '\.' --color gnugpl.txt
```

> [!NOTE]
> Кроме того, обратная косая черта — это тоже специальный символ, поэтому, если нужно использовать его в шаблоне, его тоже надо будет экранировать. Выглядит это как два слэша, идущих друг за другом: `\\`

## Якорные символы
Существуют два специальных символа для привязки шаблона к началу или к концу текстовой строки.

**Символ «крышка» — ^** позволяет описывать последовательности символов, которые находятся в начале текстовых строк. Если искомый шаблон окажется в другом месте строки, регулярное выражение на него не отреагирует. 

```bash
grep -n '^Если' --color gnugpl.txt
```

> [!IMPORTANT]
> Символ `^` предназначен для поиска шаблона в начале строки, при этом регистр символов так же учитывается.

> [!WARNING]
> Символ `^` означает начало строки, но иногда, в зависимости от контекста, означает отрицание в регулярных выражениях.

**Знак доллара** `$` в конце регулярного выражения соответствует концу строки.

> [!WARNING]
> В зависимости от ОС код символа конца строки будет отличаться. При использовании знака `$` в регулярных выражениях для поиска в файла созданных в Windows, данный спец символ не сработает. Необходимо перекодировать символ конца строки.
> [Перевод строки](https://ru.wikipedia.org/wiki/%D0%9F%D0%B5%D1%80%D0%B5%D0%B2%D0%BE%D0%B4_%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B8)

```bash
ls | grep '.txt$'
```

В одном и том же шаблоне можно использовать оба якорных символа

```bash
grep -n '^GNU General Public License$' --color gnugpl.txt
```

Как видно, шаблон среагировал лишь на строку, полностью соответствующую заданной последовательности символов и их расположению.

Выражение `^$` соответствует пустой строке.

```bash
grep -n '^$'  gnugpl.txt
```

## Символ «точка»
Точка используется для поиска любого одиночного символа, за исключением символа перевода строки. 

```bash
echo "sh is not bash. but korn shell the best" | grep --color '.sh'
```

Точка `.` означает **не менее одного** любого символа, за исключением символа перевода строки (`\n`).

```bash
grep --color '..ли' gnugpl.txt
```

## Множества символов
Кроме описания совпадения с любым символом в заданной позиции `.` в регулярных выражениях имеется возможность описать символ из определенного множества. Делается это с помощью квадратных скобок.

**Квадратные скобки** `[ ]` - предназначены для задания подмножества символов. 

Квадратные скобки, внутри регулярного выражения, считаются одним символом, который может принимать значения, перечисленные внутри этих скобок.

```bash
grep --color '[abc])' gnugpl.txt

grep --color '[ОЗ]АО' supplier_k_import.csv
```

> [!WARNING]
> Все метасимволы, кроме двух, теряют свое специальное значение внутри скобок.

Если сразу после открывающей квадратной скобки стоит символ карет `^`, остальные символы множества интерпретируются как недопустимые в данной позиции.

```bash
grep --color '[^ОЗ]АО' supplier_k_import.csv
```

**Символ отрицания не отменяет необходимости присутствия символа в заданной позиции**. Кроме того символ карет является отрицанием, только если стоит сразу же после открывающей скобки; в противном случае он теряет свое специальное значение.

С помощью дефиса `-` можно определять диапазоны символов. Так можно выразить любой диапазон символов и даже нескольких таких диапазонов.

```bash
grep --color '^[А-Д]' supplier_k_import.csv
```

Выражение `[xyz]` - соответствует одному из символов x, y или z.

Выражение `[c-n]` соответствует одному из символов в диапазоне от c до n, включительно.

Выражение `[B-Pk-y]` соответствует одному из символов в диапазоне от B до P или в диапазоне от k до y, включительно.

Выражение `[a-z0-9]` соответствует одному из символов латиницы в нижнем регистре или цифре.

Выражение `[^b-d]` соответствует любому символу, кроме символов из диапазона от b до d, включительно. В данном случае, метасимвол `^ `означает отрицание.

## Специальные классы символов
В **BRE** имеются специальные классы символов, которые можно использовать при написании регулярных выражений:

+ `[[:alpha:]]` — соответствует любому алфавитному символу, записанному в верхнем или нижнем регистре.
+ `[[:alnum:]]` — соответствует любому алфавитно-цифровому символу, а именно — символам в диапазонах 0-9, A-Z, a-z.
+ `[[:blank:]]` — соответствует пробелу и знаку табуляции.
+ `[[:digit:]]` — любой цифровой символ от 0 до 9.
+ `[[:upper:]]` — алфавитные символы в верхнем регистре — A-Z.
+ `[[:lower:]]` — алфавитные символы в нижнем регистре — a-z.
+ `[[:print:]]` — соответствует любому печатаемому символу.
+ `[[:punct:]]` — соответствует знакам препинания.
+ `[[:space:]]` — пробельные символы, в частности — пробел, знак табуляции.

```bash
grep --color '[[:digit:]]\.' gnugpl.txt

grep --color '[[:digit:]].' gnugpl.txt
```

```bash
grep --color '[[:punct:]][[:space:]]' gnugpl.txt
```

## Символ «звёздочка»
Звездочка `*` означает любое количество символов в строке, предшествующих "звездочке", в том числе и нулевое число символов.

```bash
grep --color '[Bb]et*' gnugpl.txt
```

Звёздочку можно использовать и с классами символов

```bash
echo "891234567890" | grep --color '89[[:digit:]]*'
```

Ещё одна полезная возможность, вытекающая из особенностей символа звёздочки, заключается в комбинировании его с точкой. Такая комбинация позволяет регулярному выражению реагировать на любое количество любых символов

```bash
grep --color 'http.*org' gnugpl.txt
```

> [!IMPORTANT]
> Шаблоны стандарта **POSIX ERE**, которые поддерживают некоторые утилиты Linux, могут содержать дополнительные символы.
> Ниже будут рассмотрены наиболее часто используемые в ERE-шаблонах символы, которые пригодятся при создании собственных регулярных выражений.

## Вопросительный знак
Вопросительный знак указывает на то, что предшествующий символ может встретиться в тексте один раз или не встретиться вовсе. Этот символ — один из метасимволов повторений. 

Знак вопроса `?` означает, что предыдущий символ или регулярное выражение встречается 0 или 1 раз. 

В основном используется для поиска одиночных символов.

```bash
echo "tst" | grep -E 't[ae]?st'
echo "test" | grep -E 't[ae]?st'
echo "tast" | grep -E 't[ae]?st'
echo "taest" | grep -E 't[ae]?st'
echo "teest" | grep -E 't[ae]?st'
```

Если символов из класса в строке нет, или один из них встречается один раз, регулярное выражение срабатывает, однако стоит в слове появиться двум символам и система уже не находит в тексте соответствия шаблону.

## Символ «плюс»
Символ «плюс» в шаблоне указывает на то, что регулярное выражение обнаружит искомое в том случае, если предшествующий символ встретится в тексте один или более раз. При этом на отсутствие символа такая конструкция реагировать не будет

```bash
echo "test" | grep -E 'te+st'
echo "teest" | grep -E 'te+st'
echo "tst" | grep -E 'te+st'
```

В данном примере, если символа *«e»* в слове нет, движок регулярных выражений не найдёт в тексте соответствий шаблону. 

Символ «плюс» работает и с классами символов — этим он похож на звёздочку и вопросительный знак

```bash
echo "tst" | grep -E 't[ae]+st'
echo "test" | grep -E 't[ae]+st'
echo "teast" | grep -E 't[ae]+st'
echo "teeast" | grep -E 't[ae]+st'
```

В данном случае если в строке имеется любой символ из класса, текст будет сочтён соответствующим шаблону.

## Фигурные скобки
Существуют специальные метасимволы `{` и `}`, которые, в отличие от предыдущих, позволяют выразить минимальное и максимальное число обязательных совпадений. 

Всего существует четыре возможных способа задания числа совпадений:

+ `{n}` — Совпадение, если предыдущий элемент встречается точно n раз.
+ `{n,m}` — Совпадение, если предыдущий элемент встречается не менее n и не более m раз.
+ `{n,}` — Совпадение, если предыдущий элемент встречается n или более раз.
+ `{,m}` — Совпадение, если предыдущий элемент встречается не более m раз.

```bash
echo "89123456789" | grep -E --color '89[0-9]{9}'
```

```bash
grep -E --color 'О{3}' supplier_k_import.csv

grep -E --color 'О{,3}' supplier_k_import.csv
```

## Чередование
Символ | — вертикальная черта, означает в регулярных выражениях логическое «или». Обрабатывая регулярное выражение, содержащее несколько фрагментов, разделённых таким знаком, движок сочтёт анализируемый текст подходящим в том случае, если он будет соответствовать любому из фрагментов.

```bash
grep -E --color 'ООО|ОАО|ЗАО' supplier_k_import.csv
```

## Группировка
Элементы регулярных выражений можно объединять и ссылаться на них как на один элемент. Делается это с помощью круглых скобок.

```bash
grep -E --color 'в(ы|о)з' gnugpl.txt

grep -E --color 'в(ы|о)*з' gnugpl.txt
```

```bash
ls /bin/ | grep -E --color '^b|w'

ls /bin/ | grep -E --color '^(b|w)'
```
