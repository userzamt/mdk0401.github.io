# Урок 05. Массивы
[На главную](/mdk0401.github.io)

**Массив** — структура данных, хранящая набор значений (элементов массива), идентифицируемых по индексу.

Bash поддерживает одномерные типы массивов с числовым индексом и ассоциативные массивы. Для ссылок на числовые массивы используются целые числа, а для ассоциативных ссылок — с помощью строк.

> [!WARNING]
> Нет максимального ограничения на размер массива

В отличие от большинства языков программирования, элементы массива Bash не обязательно должны иметь один и тот же тип данных. Вы можете создать массив, содержащий как строки, так и числа.

> [!WARNING]
> Bash не поддерживает многомерные массивы, и у вас не может быть элементов массива, которые также являются массивами.

## Создание
Массивы в Bash можно инициализировать по-разному.

### Создание массивов с числовой индексацией
Чтобы явно объявить массив, используйте встроенную команду declare:

```bash
declare -a array_name
```

Один из способов создать индексированный массив — использовать следующую форму:

```
array_name[index_1]=value_1
array_name[index_2]=value_2
array_name[index_n]=value_n
```

Где *index_\** — положительное целое число.


Массивы не требуют, чтобы последовательность элементов в массиве была непрерывной.

Некоторые элементы массива могут оставаться неинициализированными.
"Дырки" в массиве не являются ошибкой.

```bash
area[11]=23
area[13]=37
area[51]=UFOs

echo -n "area[11] = "
echo ${area[11]}    #  необходимы {фигурные скобки}


echo -n "area[13] = "
echo ${area[13]}

echo "содержимое area[51] = ${area[51]}."
```

Обращение к неинициализированным элементам дает пустую строку.

```bash
echo -n "area[43] = "
echo ${area[43]}        № элемент area[43] - неинициализированн
```

Другой способ создать числовой массив — указать список элементов в круглых скобках, разделенных пустым пространством:

```
array_name=( element_1 element_2 element_N )
```

Когда массив создается с использованием формы выше, индексация начинается с нуля, то есть первый элемент имеет индекс 0.

```bash
area2=( ноль один два три четыре )

echo "area2[0] = ${area2[0]}"
#  индексация начинается с нуля (первый элемент массива имеет индекс [0], а не [1]).

echo "area2[1] = ${area2[1]}"
# [1] - второй элемент массива.
```

### Создание ассоциативных массивов

В отличие от числовых индексов, ассоциативные массивы должны быть объявлены до того, как их можно будет использовать.

Чтобы объявить ассоциативный массив, используйте встроенную команду ```declare``` с параметром ```-A``` (верхний регистр)

```
declare -A array_name
```

Ассоциативные массивы можно создавать, используя следующую форму:

```bash
declare -A array_name

array_name[index_foo]=value_foo
array_name[index_bar]=value_bar
array_name[index_xyz]=value_xyz
```

Где ```index_*``` может быть любой строкой.

Вы также можете создать ассоциативный массив, используя форму ниже:

```bash
declare -A array_name

array_name=( 
  [index_foo]=value_foo 
  [index_bar]=value_bar 
  [index_xyz]=value_xyz 
)

# ******************************************
declare -A myarr=(
    [four]=4
    [5]=5
    [" "]=" space "
    [10]="ten"
    [TWO]="TWO"
)

```

## Операции с массивами

### Обращение к элементу массива
На любой элемент можно ссылаться, используя следующий синтаксис:

```bash
${array_name[index]}
```

Синтаксис доступа к элементу массива аналогичен синтаксису большинства языков программирования. Фигурные скобки ```${}``` необходимы, чтобы избежать операторов раскрытия имени файла оболочки.

```bash
declare -a my_array=( "Hydrogen" "Helium" "Lithium" "Beryllium" )

echo ${my_array[1]}     # Helium

echo ${my_array}        # Hydrogen
# массивы указывают на нулевой элемент
```

Если используются ```@``` или ```*``` в качестве индекса, слово расширяется до всех членов массива. 

```bash
declare -a my_array=( "Hydrogen" "Helium" "Lithium" "Beryllium" )

echo "${my_array[@]}" 
# "Hydrogen Helium Lithium Beryllium"
```

> [!IMPORTANT]
> ```*``` возвращает все аргументы в виде одной строки (слова)
> ```@``` то же самое, что и ```*```, но при этом каждый элемент массива представлен как отдельная строка (слово).

```bash
declare -a my_array=( "Hydrogen" "Helium" "Lithium" "Beryllium" )

echo "${my_array[*]}" 
# "Hydrogen" "Helium" "Lithium" "Beryllium"
# cycle FOR
```

### Список ключей
Чтобы распечатать ключи массива, необходимо добавить оператор ```!```  перед именем массива

```bash
${!array_name[index]}
```

Пример:

```bash
declare -a my_array=( "Hydrogen" "Helium" "Lithium" "Beryllium" )

echo "${!my_array[@]}"
# 0 1 2 3

# ****************************
declare -A arr

arr[moth1]=Январь
arr[moth2]=Февраль
arr[moth3]=Март

echo ${!arr[@]} 
# moth3 moth2 moth1
```

### Длина массива
Чтобы получить длину массива, используйте следующую форму

```
${#array_name[@]}
```

Синтаксис такой же, как и при ссылке на все элементы с добавлением символа ```#``` перед именем массива.

```bash
my_array=( "Hydrogen" "Helium" "Lithium" "Beryllium" )

## array Length
echo ${#my_array[@]}        # 4
```

> [!WARNING]
> ```${#array_name}```- это длина (количество символов) первого элемента массива, т.е. ```${array_name[0]}```

```bash
echo ${#my_array}  # 8
# "Hydrogen" = 8 символов
```





