# Урок 19. Поток управления

[На главную](/mdk0401.github.io)

Одним из основных преимуществ работы с переменными является возможность писать с их помощью код, который работает не со значением, а со *«смыслом»*. Вместо того чтобы работать, например, с числом 3, мы работаем с общим понятием *$serverCount*. За счет этого мы можем писать код, который работает одинаково, будь у вас один, два или тысяча серверов. Совместите эту способность с возможностью сохранять код в сценариях, которые можно запускать на разных компьютерах, и вы сможете начать решать задачи гораздо большего масштаба. Однако в жизни порой имеет значение, работаете ли вы с одним сервером, с двумя или с тысячей. Пока что у вас нет подходящего способа учитывать это, и ваши сценарии работают просто *«сверху вниз»*, не имея возможности адаптироваться в зависимости от определенных значений. В этой части будет рассматриваться поток управления и условная логика для написания сценариев, которые будут выполнять различные команды в зависимости от значений, с которыми они работают, а также будут рассмотрены различные циклы.

## Операторы сравнения 
Операторы сравнения позволяют сравнивать значения параметров в командах. При каждой операции сравнения создается условие, в зависимости от выполнения или невыполнения которого оператор принимает либо значение `$True` (истина), либо значение `$False` (ложь). В `PowerShell` поддерживается несколько операторов сравнения, причем для каждого такого оператора определены версии, учитывающие и не учитывающие регистр букв. 

| Оператор | Значение | Пример (возвращается значение $true)| 
| :--: | :-- | :--: | 
| -eq –ceq –ieq | равно | 10 -eq 10| 
| -ne –cne –ine | не равно | 9 -ne 10| 
| -lt –clt –ilt | меньше | 3 -lt 4| 
| -le –cle –ile | меньше или равно | 3 –le 4| 
| -gt –cgt –igt | больше | 4 -gt 3| 
| -ge –cge –ige | больше или равно | 4 -ge 3| 
| -contains -ccontains -icintains | содержит | 1,2,3 –contains 1| 
| -notcontains -cnotcontains -inotcontains | не содержит | 1,2,3 –notcontains 4| 

Базовый вариант операторов сравнения (`-eq`, `-ne`, `-lt` и т. д.) по умолчанию **не учитывает регистр букв**. Если оператор начинается с буквы *"c"* (`-ceq`, `-cne`, `-clt` и т. д.), то при сравнении **регистр букв будет приниматься во внимание**. Если оператор начинается с буквы *"i"* (`-ieq`, `-ine`, `-ilt` и т. д.), то регистр букв при сравнении не учитывается. 

> [!IMPORTANT]
> В `PowerShell` для обозначения операторов сравнения не используются обычные символы `>` и `<`, так как они зарезервированы для перенаправления ввода/вывода. 

Для операторов сравнения справедливо *"правило левой руки"*(определяющим является **тип левого операнда**). Если число сравнивается со строкой (число стоит слева от оператора сравнения), то строка преобразовывается в число и выполняется сравнение двух чисел. Если левый операнд является строкой, то правый операнд преобразуется к символьному типу и выполняется сравнение двух строк.

Если левым операндом является массив, то оператор сравнения будет возвращать те элементы этого массива, которые соответствуют правому операнду

```powershell
 1,23,4,5,6 -gt 4
```

## Операторы проверки на соответствие шаблону
Наряду с основными операторами сравнения в `PowerShell` имеются операторы проверки символьных строк на соответствие определенному шаблону.

При этом поддерживаются два вида шаблонов: выражения с подстановочными символами и регулярные выражения.

```powershell
ls p*
ls ?*pp*
```

> [!NOTE]
> `*` - любое количество произвольных символов. `?` - один произвольный символ

## Логические операторы 
Иногда внутри одной инструкции необходимо проверить сразу несколько условий. Операторы сравнения можно соединять друг с другом с помощью логических операторов. 

При использовании логического оператора `PowerShell` проверяет каждое условие отдельно, а затем вычисляет значение инструкций целиком, связывая условия при помощи логических операторов. 

| Оператор | Значение | Пример (возвращается значение $True)| 
| :--: | :-- | :--: | 
| -and | логическое И | (10 -eq 10) –and (1 –eq 1) | 
| -or | логическое ИЛИ | (9 -ne 10) –or (3 –eq 4) | 
| -not | логическое НЕ | -not (3 –gt 4) | 
| ! | логическое НЕ | !(3 -gt 4)| 

## Инструкция If … ElseIf … Else 
Логические сравнения лежат в основе практически всех алгоритмических языков программирования. В `PowerShell` при помощи инструкции `If` можно выполнять определенные блоки кода только в том случае, когда заданное условие имеет значение `$True` (истина). 

Также можно задать одно или несколько дополнительных условных блоков. Соответствующие им условия будут проверяться, если все предыдущие условия имели значение `$False`. Наконец, можно задать дополнительный блок кода, который будет выполняться в том случае, если ни одно из условий не имеет значения `$True`.

```powershell
$age = Read-Host "Сколько Вам лет? "

if ($age -lt 12) {
    Write-Error "Доступ строго воспрещён"
} elseif ($age -lt 16) {
    Write-Warning "Запрещено"
} else {
    Write-Host "Добро пожаловать"
}
```

## Цикл While 
В `PowerShell` поддерживаются несколько видов циклов. Самый простой из них — цикл `While`, в котором команды выполняются до тех пор, пока проверяемое условие имеет значение `$True`.

```powershell
While (условие) {блок_команд} 
```

При выполнении инструкции `While` оболочка `PowerShell` вычисляет раздел *условие* инструкции, прежде чем перейти к разделу *блок_команд*. Условие в инструкции принимает значения `$True` или `$False`. До тех пор, пока условие имеет значение `$True`, `PowerShell` повторяет выполнение раздела *блок_команд*. 

> [!NOTE]
> Как и в инструкции `If`, в условном выражении цикла `While` может использоваться конвейер команд `PowerShell`. 

Раздел *блок_команд* инструкции `While` содержит одну или несколько команд, которые выполняются каждый раз при входе в цикл и его повторении.

```powershell
# Get All Items from a Folder
$Files = Get-ChildItem -Path "C:\Logs"
$i = 0

# Move All files and Folders to a Arhive Location
while ($i -lt $Files.Count) {
    $File = $Files[$i]
    $NewLocation = "C:\Archive\$($File.Name)"
    Move-Item -Path $file.FullName -Destination $NewLocation
    $i++
}
```

## Циклы do/while и do/until 
Циклы `do/while` и `do/until` работают подобно циклу `while`, но противоположны друг другу: цикл `do/while` делает что-то, пока условие истинно, а цикл `do/until` делает что-то, пока условие не станет истинным. 

Пустой цикл `do/while` выглядит следующим образом

```powershell
do {  

} while ($true) 
```

Основное различие между циклом `while` и циклом `do/while` заключается в том, что `do/while` будет выполнять код до проверки условия. Это может быть удобно в определенных ситуациях, особенно если вы постоянно получаете входной сигнал от какого-то источника и хотите его обработать. 

Например, предположим, что мы хотите предложить пользователю выбрать лучший язык программирования. Для этого будем использовать цикл `do/until`.

```powershell
do {
    $choice = Read-Host -Prompt 'What is the best programming language?'
} until ($choice -eq 'PowerShell')

Write-Host 'Correct!'
```

Циклы `do/while` и `do/until` очень похожи. Часто можно за счет их сходства выполнить одни и те же действия, используя каждый цикл, просто изменив условие.

## Цикл For 
Инструкция `For` в `PowerShell` реализует еще один тип циклов — цикл со счетчиком. 

Обычно цикл `For` применяется для прохождения по массиву и выполнения определенных действий с каждым из его элементов. 

В `PowerShell` инструкция `For` используется не так часто, как в других языках программирования, так как коллекции объектов обычно удобнее обрабатывать с помощью инструкции `ForEach`. Однако если необходимо знать, с каким именно элементом коллекции или массива мы работаем на данной итерации, то цикл `For` может помочь. 

Синтаксис инструкции `For`

```powershell
For (инициация; условие; повторение) {блок_команд}
```

```powershell
$servers = '246-prep','247-server','250-prep','srvr-dc01','10.207.106.52'

for ($i = 0; $i –lt $servers.Length; $i++) {    
    # ping $servers[$i] -n 1
    Test-Connection $servers[$i] -Count 1
}
```

## Цикл ForEach 
Инструкция `ForEach` позволяет последовательно перебирать элементы коллекций. Самым простым и наиболее часто используемым типом коллекции, по которой производится перемещение, является массив. 

Обычно в цикле `ForEach` одна или несколько команд выполняются на каждом элементе массива. 

В отличие от других циклов в `PowerShell`, `ForEach` можно использовать тремя способами: в виде оператора
`foreach`, командлета `ForEach-Object` или метода `foreach()`.

### Инструкция ForEach вне конвейера команд 
В этом случае синтаксис цикла `ForEach` имеет следующий вид

```powershell
ForEach ($элемент in $коллекция) {блок_команд} 
```

В круглых скобках указывается коллекция, по которой производится итерация. При выполнении цикла `ForEach` система автоматически создает переменную *$элемент*. Перед каждой итерацией в цикле этой переменной присваивается значение очередного элемента в коллекции. В разделе *блок_команд* содержатся команды, выполняемые на каждом элементе коллекции.

```powershell
$services = Get-Service

foreach ($s in $services) {
    if($s.Status -eq "Stopped") {
        Write-Host -ForegroundColor Red $s.Name ":" $s.Status
    } else {
        Write-Host $s.Name ":" $s.Status
    }
}
```

Инструкция ForEach может также использоваться совместно с командлетами, возвращающими коллекции элементов. 

```powershell
$total = 0;

foreach ($f in ls) {
    Write-Host $f.Name "`t" $f.Length
    $total += $f.Length
}
echo "TOTAL: $total"
```

### Инструкция ForEach внутри конвейера команд 
Если инструкция `ForEach` появляется внутри конвейера команд, то `PowerShell` использует **псевдоним ForEach**, соответствующий командлету `ForEach-Object`. То есть в этом случае фактически выполняется командлет `ForEach-Object`, и уже **не нужно указывать** часть инструкции *($элемент in $коллекция)*, так как элементы коллекции блоку команд предоставляет предыдущая команда в конвейере. 

Синтаксис инструкции `ForEach`, применяемой внутри конвейера команд, в простейшем случае выглядит следующим образом

```powershell
команда | ForEach {блок_команд} 
```

Рассмотренный выше пример с подсчетом суммарного размера текстовых файлов из текущего каталога для данного варианта инструкции ForEach примет следующий вид

```powershell
$l = 0; ls | ForEach { $l += $_.Length }
```

> [!IMPORTANT]
> Специальная переменная `$_` используется в командлетах, производящих обработку элементов конвейера, для обращения к текущему объекту конвейера и извлечения его свойств. 

В общем случае в псевдониме `ForEach` может указываться не один блок команд, а три: начальный блок команд, средний блок команд и конечный блок команд. 

Начальный и конечный блоки команд выполняются один раз, а средний блок команд выполняется каждый раз при очередной итерации по коллекции или массиву. 

Синтаксис псевдонима `ForEach`, используемого в конвейере команд с начальным, средним и конечным блоками команд выглядит следующим образом: 

```powershell
команда | ForEach {начальный_блок_команд} {средний_блок_команд} {конечный_ блок_команд}
```

Для этого варианта инструкции `ForEach` пример выше можно записать следующим образом: 

```powershell
ls | ForEach {$l = 0} { $l += $_.length } {Write-Host $l}
```

### Метод foreach() 
Последний тип цикла `foreach`, который рассмотрим, — это **метод объекта foreach()**, впервые добавленный в версию `PowerShell` v4. Метод `foreach()` определен для всех массивов в `PowerShell` и может использоваться для того же, что и `foreach` и `ForEach-Object`. Он принимает **параметр блока сценария**, который содержит код, выполняемый в каждой итерации. 

Как и в случае с `ForEach-Object`, используется переменная `$_` для захвата объекта текущей итерации.

```powershell
(Get-Service).foreach({Write-Host $_.Name})

$dir = ls
$dir.foreach({Write-Host $_.Length})
```

Метод `foreach()` работает значительно быстрее предыдущих двух, и эта разница будет заметна при обработке больших наборов данных. 

## Инструкции Break и Continue 
Инструкция `Break` позволяет выйти из цикла любого типа, не дожидаясь окончания его итераций. 

```powershell
for ( ; ; ) { 
    $num = Read-Host "Input number"

    if($num -gt 5) {
       break
    }
}
```

Инструкция `Continue` осуществляет переход к следующей итерации цикла любого типа. 

```powershell
$services = Get-Service

foreach ($s in $services) {
    if($s.Status -eq "Stopped") {
        continue
    }
    Write-Host $s.Name ":" $s.Status
}
```

## Инструкция Switch 
Инструкция `Switch`, объединяющая несколько проверок условий внутри одной конструкции, имеется во многих языках программирования. 

Однако в языке `PowerShell` данная инструкция обладает мощными дополнительными возможностями: 

+ она может использоваться как аналог цикла, проверяя значения не единственного элемента, а целого массива;

+ она может проверять элементы на соответствие шаблону с подстановочными символами или регулярными выражениями;

+ она может обрабатывать текстовые файлы, используя в качестве проверяемых элементов строки из файлов.

```powershell
switch (выражение) {
    значениевыражения {
        # Код
    }
    значениевыражения {
    }
    
    default {
    # Код, который выполняется при отсутствии совпадений
    }
}
```

### Виды проверок внутри Switch 
Рассмотрим вначале самую простую форму инструкции `Switch`, когда одно скалярное выражение по очереди сопоставляется с несколькими условиями.

```powershell
$count = (ls).Length

switch ($count) {
    1 { Write-Host "One" }
    2 { Write-Host "Two" }
    3 { Write-Host "Three" }

    default { Write-Host "More $count"  }
}
```

Если для проверяемого значения справедливы несколько условий из списка, то будут выполнены все действия, сопоставленные этим условиям.

```powershell
$num = 2 

switch ($num) {
    1 { Write-Host "One" }
    2 { Write-Host "Two"; <#break#> }
    3 { Write-Host "Three" }
    2 { Write-Host "Another two" }
}
```

По умолчанию в инструкции `Switch` производится прямое сравнение с объектами, указанными в условии. Сравнение строк при этом производится без учета регистров символов

```powershell
Switch ('абв') {
    'абв' {"Первое совпадение"}
    'АБВ' {"Второе совпадение"}
}
```

Если при сравнении следует учесть регистр символов, то нужно указать параметр `-CaseSensitive`
 
```powershell
Switch -CaseSensitive ('абв') {
    'абв' {"Первое совпадение"}
    'АБВ' {"Второе совпадение"}
}
```

Кроме обычного сравнения можно проверять элементы на соответствие шаблону с подстановочными символами. Для этого используется переключатель `-Wildcard`

```powershell
Switch -Wildcard ('абв') {
    'а*' {"Начинается с а"}
    '*в' {"Оканчивается на в"}
}
```

Проверяемый элемент (объект) доступен внутри инструкции `Switch` через специальную переменную `$_ `

```powershell
Switch -Wildcard ('абв') {
    'а*' {"$_ начинается с а"}
    '*в' {"$_ оканчивается на в"}
}
```

Переключатель `-Regex` позволяет проверять элементы на соответствие шаблону, содержащему регулярные выражения 

```powershell
Switch -Regex ('абв') {
    '^а' {"$_ начинается с а"}
    'в$' {"$_ оканчивается на в"}
}
```

Кроме проверок на простое совпадение или соответствие шаблону, инструкция `Switch` позволяет производить более сложные проверки, указывая вместо шаблонов **блоки кода на языке** `PowerShell`. Проверяемое значение при этом
вновь доступно через переменную `$_` 

```powershell
Switch (10) {
    {$_ -gt 5} {"$_ больше 5"}
    {$_ -lt 20} {"$_ меньше 20"}
    10 {"$_ равно 10"}
}
```

В данном случае выполняются все три проверяемых условия: значения первых двух выражений *"10 -gt 5"* и *"10 -lt 20"* равны `$True`, третье условие — обычное сравнение двух чисел на равенство *(10 равно 10)*. 

## Проверка массива значений
До настоящего момента все значения, которые проверяли в инструкции `Switch`, были скалярными величинами. Язык `PowerShell` допускает использование в качестве проверяемого значения массивы элементов, причем массивы могут задаваться явно или получаться в результате выполнения какой-либо команды, скажем, путем считывания строк из текстового файла. 

```powershell
Switch (1,2,3,4,5,6) {
    {$_ % 3} {"$_ не делится на три"}

    Default {"$_ делится на три"}
}
```

Необходимо узнать количество файлов с расширениями *txt* и *log*, находящихся в  каталоге

```powershell
$txt=$log=0

Switch -Wildcard (ls) {
    *.txt {$txt++}
    *.log {$log++}
}
```

Для использования в качестве входного массива строк из определенного текстового файла нужно указать в инструкции `Switch` параметр `-File` и путь к нужному файлу.

```powershell
Switch -Wildcard -File $env:SystemRoot\KB946627.log {
    *Source:* {$_}
    *Destination:* {$_}
}
```
