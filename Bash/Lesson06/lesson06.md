# Урок 06. Ветвление. Операции сравнения. Сравнение файлов
[На главную](/mdk0401.github.io)

Ветвления в Bash оформляются так, как это было придумано в оригинальном Bourne Shell:

```
if <командный список>; then
    <командный список>
elif <командный список>; then
    <командный список>
else
    <командный список>
fi
```

**Командным списком в Bash называется последовательность, состоящая минимум из одной команды или одного конвейера**. Интерпретатор распознает командный список по следующим синтаксическим якорям:

+ строка заканчивается точкой с запятой (;), амперсандом (&) или символом новой строки;

+ предыдущее условие плюс, если команд несколько, они отделяются символом точки с запятой (;), амперсандом (&), двойным амперсандом (&&), либо двумя вертикальными линиями (||).

**Обратим внимание на следующие важные моменты**

+ Выражение после ключевых слов ```if``` и ```elif``` является командным списком, т.е. при желании вы можете написать в условии целую подпрограмму в соответствии с правилами оформления командных списков. Эта особенность отличает язык командной оболочки от многих языков программирования, например языка Си, где есть понятие условное выражение.

+ По умолчанию, в командном списке анализируется только код самой последней команды этого списка. Для конвейеров анализируется только результат последней команды конвейера. **ИСТИНОЙ в Bash считается нулевой возвращаемый код, а все другие являются ЛОЖЬЮ**.

+ Командный список, исполняемый на одной из ветвей не должен быть пустым. Пустой список является синтаксической ошибкой.

+ Для ```if``` и ```elif``` признаком начала тела ветвления является ключевое слово ```then```, и это обязательная часть синтаксиса языка. Концом ответвления является начало следующего, ключевое слово ```fi```, либо ```else```. Следующее за ```then``` слово интерпретируется как команда, поэтому при желании часть командного списка тела ветвления (или весь командный список), может находиться с ```then``` на одной строке и никак специально не разделяться.

+ Ответвление ```else``` должно находиться всегда последним и следующая за ```else``` строка интерпретируется как команда. Для этого ответвления признаком конца является ключевое слово ```fi```.
    
+ Как и в любом другом языке программирования, с похожим оформлением ветвлений, ответвления ```elif``` и ```else``` являются не обязательными.

Абстрагируясь от командного наполнения, следующая запись демонстрирует синтаксически верную запись одной строкой.

```bash
if : ; then : ; elif : ; then : else : ; fi

# Многострочная запись №1
if :; then
   :
elif :; then
   :
else 
  :
fi
# Многострочная запись №2 (классическая)
if :
then
   :
elif :
then
   :
else 
  :
fi
```

Для демонстрации использовалась команда-пустышка ```:```, которая всегда возвращает нулевой код и ничего не делает. По смыслу эта команда соответствует pass в Python. Использовали её в конструкциях ветвления, потому что командные списки не могут быть пустыми.

Ввиду того что синтаксис ветвления в Bourne Shell был вдохновлен языком Алгол-68, а первые языки (такие как Алгол-68) испытывали тенденции быть похожими на английский язык, используется ключевое слово ```then```, чтобы обозначить начало блока ветвления. В современных реалиях это уже кажется неудобным архаизмом, но исторически сложилось так, как сложилось.

```bash
domain="youtube.com"
text_search="update"

if  grep $domain access.log --color
then
    echo "Find $domain"
elif grep $text_search access.log --color
then
    echo "Find $text_search"
else
    echo "Not found"
fi
```

```bash
# true
if ((1))
then
    echo "Result OK"
else
    echo "False"
fi
```
См. ниже

## Команда ```test```
Команда ```test``` служит для того, чтобы эмулировать условные выражения в языке командной оболочки. Самая первая реализация ```test``` была отдельной программой, которой передавалась условная конструкция. **По договоренности, эта программа возвращала 0, если переданное условие истинно, и 1 — если ложно**.

Так как все сценарии изобилуют условными проверками, команда получила более короткий псевдоним в виде квадратной скобки — ```[```.  Однако у оригинальной команды ```test``` специфичный перегруженный синтаксис, который часто приводит к ошибкам у начинающих программистов. В Bash поддерживается POSIX-совместимый ```test``` и вводится его усовершенствованная встроенная версия в виде оператора ```[[```. Далее по тексту, под командой ```test``` будет пониматься как ```[```, так и ```[[```, если не требуется уточнение.

Если вы пишите не портируемые сценарии, исключительно для оболочки Bash, то следует отдавать предпочтение модернизированной версии ```test```, так как она в целом удобнее. Тем не менее, следует помнить, что в портируемых сценариях вы должны пользоваться только POSIX совместимым вариантом. Вариант ```[[``` кроме Bash так же поддерживается в Ksh и Zsh.

```bash
# проверка на равенство
test 1 -eq 2 && echo true || echo false
```

```bash
# проверка на 1 > 2
test 1 -gt 2        # 1 - ошибка. неверное условие

# увидеть код завершения последней команды
echo $?             # специальная переменная
```

## Сравнение чисел
В скриптах можно сравнивать числовые значения.  При сравнении чисел используются операторы, являющиеся англоязычными сокращениями. Ниже приведён список соответствующих команд.

```
-eq равно (equal)
-ne не равно (not equal)
-lt меньше (less)
-le меньше или равно (less than or equal)
-gt больше (greater)
-ge больше или равно (greater)s
```

```bash
filename="access.log"
res=$(wc -l < $filename)

# должны быть пробелы между [ ]
if [ $res -gt 150 ]
then
    echo "Больше 150"
elif [ $res -lt 149 ]
then
    echo "Меньше 149"
else
    echo "Меньше 100"
fi
```

## Сравнение строк
В сценариях можно сравнивать и строковые значения. Операторы сравнения выглядят довольно
просто, однако у операций сравнения строк есть определённые особенности. При сравнении строк используются привычные операторы:

```
=    равно
==   тоже равно
!=   не равно
<    меньше 
>    больше
```

```bash
# env
# воспользуемся USER

user_check="student"

if [ $user_check = $USER ]
then
    echo "The user $USER is the current logged in user"
fi
```

Кроме математических выражений, для строк доступны следующие условия:

```
string      строка не нулевая или не определена
-n string   строка не нулевая и существует
-z string   строка нулевая и существует
```

> [!IMPORTANT]
> Оператор ```-n``` требует, чтобы строка была заключена в кавычки внутри квадратных скобок. Как правило, проверка строк, не заключенных в кавычки, оператором ! -z, или просто указание строки без кавычек внутри квадратных скобок, проходит нормально, однако это небезопасная, с точки зрения отказоустойчивости, практика. **Всегда заключайте проверяемую строку в кавычки**

```bash
if [ -n "$str" ]
then
    echo "Не существует"
fi
```

> [!WARNING]
> Обратите внимание! Символ ```<``` и ```>``` необходимо экранировать внутри ```[]```

```bash
# сравнение ASCII-кодов
str="B"

if [ "$str" \> "a" ]
then
    echo "$str > a"
elif [ "$str" \< "Z" ]
then
    echo "$str < Z"
fi
```


## Двойные круглые скобки
В Ksh, Bash и Zsh также есть еще одна разновидность команды ```test```, которая может работать только с числами. В этой версии все операторы работают с числами, как это ожидается для чисел, но в портируемых скриптах этой возможностью пользоваться нельзя.

```bash
(( 5 == 5 ))
(( 4 > 3 ))
(( 3 < 4 ))
(( 21 >= 25 ))
(( 100 <= 255 ))
(( 6 != 5 ))
```

Эта версия ```test``` сложнее чем кажется и поддерживает разные операторы как арифметическая подстановка, но без вывода результата, например

```bash
(( 2 + 2 == 4 )) # ИСТИНА
```

## Двойные квадратные скобки
```[``` — является специальной встроенной командой test воспринимающей свои аргументы как выражение сравнения.

```[[``` — расширенный вариант от ```[```, является зарезервированным словом, а не командой, его bash выполняет как один
элемент с кодом возврата.

> [!IMPORTANT]
> ```[[``` менее строгий вариант 

```bash
n1=12
n2=7

if [ $n1 -gt $n2 ]
then
    echo "$n1 < $n2"
fi

#if [$n1 -gt $n2 ]       # error
#if [ $n1 -gt $n2]       # error
```

```bash
a=a
b=b

if [ "$a" \< "$b" ]
then
    echo "$a < $b"
fi
```

### Сравнение [ и [[
#### Сравнение строк
|[ ]| [[ ]]|
| :--: | :--: |
| [ a \> b ] | [[ a > b ]] |
| [ a \< b ] | [[ a < b ]] |
| [ a = b ] | [[ a = b ]] или [[ a == b ]] |
| [ a != b ] | [[ a != b ]] |

#### Сравнение чисел
|[ ]| [[ ]]| Описание |
| :--: | :--: | :-- |
| [ 5 -gt 10 ] | [[ 5 -gt 10 ]] | больше |
| [ 5 -lt 10 ] | [[ 5 -lt 10 ]] | меньше |
| [ 5 -ge 10 ] | [[ 5 -ge 10 ]] | больше или равно |
| [ 5 -le 10 ] | [[ 5 -le 10 ]] | меньше или равно |
| [ 5 -eq 10 ] | [[ 5 -eq 10 ]] | равно |
| [ 5 -ne 10 ] | [[ 5 -ne 10 ]] | не равно |

## Логические операторы
! - отрицание логического выражения

-a,(&&) – логическое *И*

-o,(||) - логическое *ИЛИ*

```bash
a=1
b=5
c=3

if [ $a -lt $b  -a  $b -gt $c ]
then
    echo "$b maximum"
fi

#if [ $a -lt $b ] && [ $b -gt $c ]
```

```bash
a=a
z=z
c=c

if [[ $a < $z && $z > $c ]]
then
    echo "$z maximum"
fi
```

## Проверки файлов
Пожалуй, нижеприведённые команды используются в bash-скриптах чаще всего. Они позволяют проверять различные условия, касающиеся файлов.

|Команда|Описание|
| :--: | :-- |
|-d file | Проверяет, существует ли файл, и является ли он директорией. |
|-e file | Проверяет, существует ли файл. |
|-f file | Проверяет, существует ли файл, и является ли он файлом. |
|-r file | Проверяет, существует ли файл, и доступен ли он для чтения. |
|-s file | Проверяет, существует ли файл, и не является ли он пустым. |
|-w file | Проверяет, существует ли файл, и доступен ли он для записи. |
|-x file | Проверяет, существует ли файл, и является ли он исполняемым. |
|file1 -nt file2 | Проверяет, новее ли file1, чем file2. |
|file1 -ot file2 | Проверяет, старше ли file1, чем file2. |
|-O file | Проверяет, существует ли файл, и является ли его владельцем текущий пользователь. |
|-G file | Проверяет, существует ли файл, и соответствует ли его идентификатор группы идентификатору группы текущего пользователя. |

```bash
mydir=/home/likegeeks

if [ -d $mydir ]
then
    echo "The $mydir directory exists"
    cd $mydir
    ls
else
    echo "The $mydir directory does not exist"
fi
```

> [!WARNING]
> В Cygwin нет стандартных файлов ```/etc/passwd``` и ```/etc/group```

```bash
if ! [ -e "/etc/passwd" ] ;then
    mkpasswd -l > /etc/passwd
else
    rm /etc/passwd
fi
```