# Урок 18. Объединение команд

[На главную](/mdk0401.github.io)

До сих пор мы использовали консоль `PowerShell` для вызова команд по одной. Для простого кода это не проблема: вы запускаете нужную команду, а затем еще одну, если требуется. Но для более крупных проектов необходимость вызывать каждую команду по отдельности занимает слишком много времени. 

К счастью, вы можете комбинировать команды, чтобы вызывать их как единое целое. Существует два способа комбинирования команд — с помощью **конвейера** `PowerShell` и путем сохранения кода во внешних сценариях.

В большинстве оболочек командной строки, включая `cmd.exe`, под конвейеризацией понимается объединение нескольких команд путем последовательного перенаправления выходного потока одной команды во входной поток другой, что позволяет передавать текстовую информацию между разными процессами.

Механизм композиции команд представляет собой, вероятно, наиболее ценную концепцию, используемую в интерфейсах командной строки. Конвейеры не только снижают усилия, прилагаемые при вводе сложных команд, но и облегчают отслеживание выполняемых командами действий. 

Полезной чертой конвейеров является то, что они не зависят от числа передаваемых элементов, так как конвейер действует на каждый элемент отдельно. Кроме того, каждая команда в конвейере (называемая элементом конвейера) обычно передает свой вывод следующей команде в конвейере, элемент за элементом. Благодаря этому, как правило, снижается потребление ресурсов для сложных команд и появляется возможность получать выводимую информацию немедленно.

## Запуск службы Windows 
Чтобы показать, зачем стоит комбинировать команды, начнем с простого примера, который выполним по старинке. Будем использовать две команды: `Get-Service`, которая запрашивает службы Windows и возвращает информацию о них, и `Start-Service`, запускающую эти службы.

```powershell
Get-Service
```

```powershell
Start-Service 'wuauserv'
```

Когда вы запускаете только одну службу, выполнение таких команд не слишком напрягает. Но представьте, как вам это надоест, если речь пойдет о работе с сотнями сервисов.

> [!NOTE]
> Для остановки служб используется командлет `Stop-Service`

## Использование конвейера 
Первый способ упростить код — объединить команды в цепочку с помощью конвейера `PowerShell`. Это инструмент, который позволяет передавать выходные данные одной команды непосредственно во входные данные другой. 

Чтобы использовать конвейер, добавьте оператор вертикальной черты `|` между двумя командами

```powershell
команда1 | команда2 
```

Последняя команда конвейера будет выведена на консоль.

> [!NOTE]
>  Во многих языках сценариев оболочки, включая `cmd.exe` и `bash`, используется конвейер.

В оболочке `PowerShell` также очень широко используется механизм конвейеризации команд, однако здесь по конвейеру передается **не поток текста**, как во всех других оболочках, **а объекты**. При этом с элементами конвейера можно производить различные манипуляции: фильтровать объекты по определенному критерию, сортировать и группировать объекты, изменять их структуру.

```powershell
Get-Service -Name 'wuauserv' | Start-Service
```

Уже не нужно указывать какие-либо параметры, потому что `PowerShell` сделает это за вас. Система просмотрит выходные данные `Get-Service`, поймет, какие значения следует передать в `Start-Service`, и сопоставит значения с параметрами, которые `Start-Service` принимает на вход.

При желании можно переписать конвейер вообще без параметров

```powershell
'wuauserv' | Get-Service | Start-Service
```

Для анализа структуры объекта, возвращаемого определенной командой, проще всего направить этот объект по конвейеру на командлет `Get-Member`

```powershell
'wuauserv' | Get-Service | Get-Member
```

## Передача массивов между командами
Вариант передачи массива данных по конвейеру

```powershell
'aspnet_state','PeerDistSvc','CDPSvc' | Get-Service
```
Удобнее использовать для таких целей текстовый файл. В папке с лекцией есть текстовый файл *services.txt*, в котором содержится перечень служб. Чтобы отобразить файл в окне `PowerShell`, используйте командлет `Get-Content`

```powershell
Get-Content -Path C:\services.txt 
Get-Content services.txt 
```

Команда `Get-Content` читает файл построчно, добавляя каждую строку в массив, который затем возвращает.

```powershell
Get-Content services.txt | Get-Service
```

Команда `Get-Content` читает текстовый файл и выдает массив. Но вместо того, чтобы отправлять через конвейер сам массив, `PowerShell` разворачивает его и прогоняет каждый элемент через конвейер по одному. Это позволяет выполнять одну и ту же команду для каждого элемента в массиве. 

Поместив каждую службу для запуска в текстовый файл и добавив приписку `| Start-Service` к команде, то получится команда, которая сможет запустить сколько угодно служб. 

Ограничений на количество команд, которые вы можете *«склеить»* с помощью конвейера, нет. Но если вы заметите, что их число превысило пять, вам, возможно, придется пересмотреть подход. Обратите внимание, что конвейер — это мощный инструмент, но он будет работать не всегда: большинство команд `PowerShell` **принимают только определенные типы входных данных** из конвейера, **а некоторые не принимают вообще** никаких. 

## Фильтрация объектов (командлет Where-Object) 
В `PowerShell` поддерживается возможность фильтрации объектов в конвейере, то есть **удаления из конвейера объектов, не удовлетворяющих определенному условию**. 

Данную функциональность обеспечивает командлет `Where-Object`, позволяющий проверить каждый объект, проходящий через конвейер, и передать его дальше по конвейеру лишь в том случае, если объект удовлетворяет условиям проверки. 

Условие проверки в `Where-Object` задается в виде блока сценария (*scriptblock*) — одной или нескольких команд `PowerShell`, заключенных в фигурные скобки `{}`. Блок сценария указывается после имени командлета `Where-Object`. 

Результатом выполнения блока сценария в командлете `Where-Object` должно быть значение логического типа: `$True` (истина, в этом случае объект проходит далее по конвейеру) или `$False` (ложь, в этом случае объект далее по конвейеру не передается). 

Например, для вывода информации об остановленных службах в системе (объекты, возвращаемые командлетом `Get-Service`, у которых свойство `Status` равно *"Stopped"*) можно использовать следующий конвейер

```powershell
Get-Service | Where-Object {$_.Status -eq "Stopped"}
```

Получим процессы которые потребляют более 8КБ памяти

```powershell
Get-Process | Where-Object {$_.WS -gt 8092kb}
```

> [!IMPORTANT]
> В `PowerShell` предусмотрены специальные суффиксы-множители для упрощения работы с величинами, часто используемыми системными администраторами: `kb` - умножение килобайта, `mb` - Умножение мегабайта, `gb` - умножение гигабайт, `tb` - умножение терабайтов

В блоках сценариев командлета `Where-Object` для обращения к текущему объекту конвейера и извлечения нужных свойств этого объекта используется специальная переменная `$_`, которая создается оболочкой `PowerShell` автоматически. 

| Оператор | Значение | Пример (возвращается значение True)| 
| :--: | :-- | :--: | 
| -eq | равно | 10 -eq 10| 
| -ne | не равно | 9 -ne 10| 
| -lt | меньше | 3 -lt 4 | 
| -le | меньше или равно | 3 –le 4| 
| -gt | больше | 4 -gt 3 | 
| -ge | больше или равно | 4 -ge 3| 
| -like | сравнение на совпадение с учетом подстановочного знака во втором операнде | "file.doc" –like "f*.doc" | 
| -notlike | сравнение на несовпадение с учетом подстановочного знака во втором операнде | "file.doc" –notlike "f*.rtf"| 
| -contains | содержит | 1,2,3 –contains 1| 
| -notcontains | не содержит | 1,2,3 –notcontains 4| 

Операторы сравнения можно соединять друг с другом с помощью логических операторов

| Оператор | Значение | Пример (возвращается значение True)| 
| :--: | :-- | :--: | 
| -and | логическое И | (10 -eq 10) –and (1 –eq 1)| 
| -or | логическое ИЛИ | (9 -ne 10) –or (3 –eq 4)| 
| -not | логическое НЕ | -not (3 –gt 4)| 
| ! | логическое НЕ | !(3 -gt 4)| 

## Сортировка объектов (командлет Sort-Object) 
Сортировка элементов конвейера — еще одна операция, которая часто применяется при конвейерной обработке объектов. 

Данную операцию осуществляет командлет `Sort-Object`: ему передаются имена свойств, по которым нужно произвести сортировку объектов, проходящих по конвейеру, а он возвращает данные, упорядоченные по значениям этих свойств. 

Например, для вывода списка запущенных в системе процессов, упорядоченного по затраченному процессорному времени (свойство *cpu*), можно воспользоваться следующим конвейером

```powershell
Get-Process | Sort-Object CPU
Get-Process | Sort-Object -Property CPU
```

Для сортировки в обратном порядке используется параметр `-Descending`

```powershell
Get-Service | Sort-Object Status -Descending
```

Конвейер может объединять и большее количество команд

```powershell
Get-Service | Where-Object {$_.Status -eq "Running"} | Sort-Object DisplayName
```

## Выделение объектов и свойств (командлет Select-Object) 
В `PowerShell` имеется командлет `Select-Object`, с помощью которого **можно выделять** указанное количество объектов с начала или с конца конвейера, выбирать уникальные объекты из конвейера, а также выделять определенные свойства в объектах, проходящих по конвейеру. 

Для выделения из конвейера нескольких первых или последних объектов следует воспользоваться соответственно параметрами `-First` или `-Last`  командлета `Select-Object`.

```powershell
Get-Process | Sort-Object WS | Select-Object -Last 5
```

Первый командлет в конвейере `Get-Process` возвращает массив объектов, соответствующих запущенным в системе процессам. Второй командлет `Sort-Object` упорядочивает проходящие по конвейеру объекты по значению свойства `WS` (объем памяти, занимаемой процессом). Наконец, третий командлет `Select-Object` выбирает из упорядоченного массива объекта последние пять элементов. 

Предположим теперь, что необходимо получить список запущенных в системе процессов, в котором были бы указаны только имена процессов и их идентификаторы. 

> [!WARNING]
> Названия нужных свойств можно получить с помощью командлета `Get-Member` 

```powershell
Get-Process | Sort-Object WS | Select-Object -Last 5 Id,WS,ProcessName
Get-Process | Select-Object Id,WS,ProcessName
```

> [!IMPORTANT]
> При использовании командлета `Select-Object` для выбора указанных свойств он копирует значения этих свойств из объектов, поступающих по конвейеру ему на вход, и создает новые объекты, которые содержат указанные свойства со скопированными значениями. Выходной объект имеет тип `System.Management.Automation.PSCustomObject`

## Выполнение произвольных действий над объектами в конвейере (командлет ForEach-Object) 
Командлет `ForEach-Object` позволяет выполнить определенный блок сценария для каждого объекта в конвейере. Другими словами, с помощью данного командлета можно производить произвольные операции над элементами конвейера. 

Для примера подсчитаем общий объем файлов, хранящихся в корневом каталоге диска `c:`. Для этого сначала перейдем в данный каталог и объявим переменную $total

```powershell
Set-Location C:\
$total = 0
ls | ForEach-Object { $total += $_.Length }
echo $total
```

В блоке сценария командлета `ForEach-Object` к текущему значению переменной `$total` прибавляется значение свойства `Length` проходящего через конвейер объекта (размер соответствующего этому объекту файла). В результате в переменной будет храниться общий размер файлов в байтах.

## Группировка объектов (командлет Group-Object) 
Проходящие по конвейеру объекты можно сгруппировать по значению определенных свойств с помощью командлета `Group-Object`. В одну группу будут попадать объекты, имеющие одинаковые значения указанных свойств (свойства могут быть вычисляемыми). 

Командлет `Get-Process` генерирует объекты, имеющие свойства *Company* (название компании-разработчика определенного модуля, запущенного в операционной системе в качестве процесса). Выполним группировку этих объектов по значению свойства *Company*

```powershell
Get-Process | Group-Object Company
```

В колонке *Count* отображается количество элементов в каждой из групп, а в колонке *Group* перечислены элементы, входящие в группы. 

Если нужно просто узнать количество элементов в группах, можно запустить командлет `Group-Object` с параметром `-NoElement`

```powershell
Get-Process | Group-Object Company -NoElement
```

## Измерение характеристик объектов (командлет Measure-Object) 
В `PowerShell` имеется еще один полезный командлет `Measure-Object`, предназначенный для выполнения функций агрегирования (сумма, выбор минимального, максимального или среднего значения) над свойствами элементов в конвейере объектов. 

Ранее мы уже находили общий размер файлов в корневом каталоге диска `C:`, применяя для этого командлет `ForEach-Object`

```powershell
Set-Location C:\
$total = 0
ls | ForEach-Object { $total += $_.Length }
echo $total
```

С помощью командлета `Measure-Object` также можНо найти суммарный размер файлов. Для этого нужно указать, что `Measure-Object` должен для всех элементов конвейера просуммировать (параметр `-Sum`) значения свойства *Length*

```powershell
ls | Measure-Object Length -Sum
ls | Measure-Object -Property Length -Sum
```

Для выполнения других операций нужно указать соответствующий параметр: `-Average` для нахождения среднего значения, `-Minimum` или `-Maximum` для нахождения минимального или максимального значения соответственно.
