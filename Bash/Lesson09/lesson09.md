# Урок 09. Ввод и вывод
[На главную](/mdk0401.github.io)

Иногда что-то надо показать на экране, а что-то — записать в файл, поэтому нужно разобраться с тем, как в Linux обрабатывается ввод и вывод, а значит — научиться отправлять результаты работы сценариев туда, куда нужно. 

## Стандартные дескрипторы файлов
Всё в Linux — это файлы, в том числе — ввод и вывод. Операционная система идентифицирует файлы с использованием дескрипторов.

**Дескриптор файла** - это просто число, по которому система идентифицирует открытые файлы. Рассматривайте его как упрощенную версию указателя на файл.

**Файловые дескрипторы** - это способ, которым программы ссылаются на файлы или на другие ресурсы, которые работают как файлы (такие как каналы, устройства, сокеты или терминалы). Это что-то вроде указателей на источники данных или места, куда могут быть записаны/считаны данные. 

По умолчанию каждый новый процесс начинается с трех открытых дескрипторов

+ 0, STDIN — стандартный поток ввода
+ 1, STDOUT — стандартный поток вывода
+ 2, STDERR — стандартный поток ошибок

Каждому процессу позволено иметь до **девяти** открытых дескрипторов файлов. Оболочка bash резервирует первые три дескриптора с идентификаторами ```0```, ```1``` и ```2```

> [!IMPORTANT]
>  Иногда дополнительные дескрипторы могут сослужить неплохую службу, временно сохраняя в себе ссылку на stdin, stdout или stderr. Это упрощает возврат дескрипторов в нормальное состояние после сложных манипуляций с перенаправлением и перестановками

В интерактивной оболочке или в скрипте, запущенном на терминале, стандартный ввод - это символы, которые вы вводите на клавиатуре. Стандартный вывод - это то, куда программа отправляет большую часть своей обычной информации, чтобы пользователь мог ее увидеть(окно терминала), а стандартная ошибка - это то, куда программа отправляет свои сообщения об ошибках.

Приложения с графическим интерфейсом также имеют эти дескрипторы, но обычно они с ними не работают. Обычно они осуществляют все свое взаимодействие с пользователем через графический интерфейс.

В соответствии с соглашениями, команды принимают ввод из файла с дескриптором 0 (stdin), выводят результат работы в файл с дескриптором 1 (stdout), а сообщения об ошибках в файл с дескриптором 2 (stderr). 

Эти три специальных дескриптора обрабатывают ввод и вывод данных в сценарии. Вам нужно как следует разобраться в стандартных потоках. Их можно сравнить с фундаментом, на котором строится взаимодействие скриптов с внешним миром. 

## STDIN
**STDIN** — это стандартный поток ввода оболочки. Для терминала стандартный ввод — это клавиатура.

Когда в сценариях используют символ перенаправления ввода — ```<```, Linux заменяет дескриптор файла стандартного ввода на тот, который указан в команде. Система читает файл и обрабатывает данные так, будто они введены с клавиатуры.

```bash
wc < file.txt
```

```bash
wc <<< "Hello world"
```

> [!IMPORTANT]
> Если входной файл не задан, то данные считываются со стандартного ввода. При выводе, в первой колонке содержится количество строк, во второй — слов, в третьей — символов.

```bash
bc <<< 85*96
```

Многие команды bash принимают ввод из STDIN, если в командной строке не указан файл, из которого надо брать данные. 

Например, это справедливо для команды ```cat```. Когда вы вводите команду ```cat``` в командной строке, не задавая параметров, она принимает ввод из STDIN. После того, как вы вводите очередную строку, ```cat``` просто выводит её на экран.

```bash
cat
```

## STDOUT
**STDOUT** — стандартный поток вывода оболочки. По умолчанию это — экран. 

### COMMAND_OUTPUT >
Перенаправление stdout (вывода) в файл.

Если файл отсутствовал, то он создается, иначе перезаписывается.

```bash
ls -lR > dir-tree.list
# Создает файл, содержащий список дерева каталогов.

: > filename
# Операция > усекает файл "filename" до нулевой длины.
# Если до выполнения операции файла не существовало,
# то создается новый файл с нулевой длиной (тот же эффект дает команда 'touch').
# Символ : выступает здесь в роли местозаполнителя, не выводя ничего.

> filename
# Операция > усекает файл "filename" до нулевой длины.
# Если до выполнения операции файла не существовало,
# то создается новый файл с нулевой длиной (тот же эффект дает команда 'touch').
# (тот же результат, что и выше - ": >", но этот вариант неработоспособен
# в некоторых командных оболочках.)

/dev/null > filename
```

### >>
Большинство bash-команд выводят данные в STDOUT, что приводит к их появлению в консоли. Данные можно перенаправить в файл, присоединяя их к его содержимому, для этого служит команда ```>>```.

Итак, у нас есть некий файл с данными, к которому мы можем добавить другие данные с помощью этой команды:

```bash
pwd >> myfile
```

То, что выведет pwd, будет добавлено к файлу ```myfile```, при этом уже имеющиеся в нём данные никуда не денутся.

Что будет если попытаться выполнить что-то вроде показанного выше, обратившись к несуществующему файлу (например nonexistentfile.txt)

```bash
ls nonexistentfile.txt >> myLog.txt
```

После выполнения этой команды мы увидим сообщения об ошибках на экране.

При попытке обращения к несуществующему файлу генерируется ошибка, но оболочка не перенаправила сообщения об ошибках в файл, выведя их на экран. Но что если мы хотим, чтобы сообщения
об ошибках попали в файл?

## STDERR
STDERR представляет собой стандартный поток ошибок оболочки. По умолчанию этот дескриптор указывает на то же самое, на что указывает STDOUT, именно поэтому при возникновении ошибки мы видим сообщение на экране.

Итак, предположим, что надо перенаправить сообщения об ошибках, скажем, в лог-файл, или куда-нибудь ещё, вместо того, чтобы выводить их на экран.

## Перенаправление потоков
### Перенаправление потока ошибок
Как вы уже знаете, дескриптор файла STDERR — 2. Мы можем перенаправить ошибки, разместив этот дескриптор перед командой перенаправления:

```bash
ls nonexistentfile.txt >> myLog.txt 2> err.log
```

Сообщение об ошибке теперь попадёт в файл err.log

### Перенаправление потоков ошибок и вывода
При написании сценариев командной строки может возникнуть ситуация, когда нужно организовать и перенаправление сообщений об ошибках, и перенаправление стандартного вывода. Для того, чтобы этого добиться, нужно использовать команды перенаправления для соответствующих дескрипторов с указанием файлов, куда должны попадать ошибки и стандартный вывод

```bash
ls clients.csv >> file.txt 2> err.log 1> my.log
```

Оболочка перенаправит то, что команда обычно отправляет в STDOUT, в файл ```my.log``` благодаря конструкции ```1>```. Сообщения об ошибках, которые попали бы в STDERR, оказываются в файле ```err.log ```из-за команды перенаправления ```2>```.

STDERR, и STDOUT можно перенаправить в один и тот же файл, воспользовавшись командой ```&>```

```bash
ls clients.csv &> my.log
```

> [!WARNING]
> Мы рассмотрели работку с потоками в терминале. Теперь рассмотрим работу с потоками при написании скриптов

## Перенаправление вывода в скриптах
Существует два метода перенаправления вывода в сценариях командной строки:

+ Временное перенаправление, или перенаправление вывода одной строки.

+ Постоянное перенаправление, или перенаправление всего вывода в скрипте либо в какой-то его части.

### Временное перенаправление вывода
В скрипте можно перенаправить вывод отдельной строки в STDERR. Для того, чтобы это сделать, достаточно использовать команду перенаправления, указав дескриптор STDERR, при этом перед номером дескриптора надо поставить символ амперсанда (```&```)

```bash
echo "Its error" >&2        # !!! >&2
echo "Information for user"
```

Если запустить скрипт, обе строки попадут на экран, так как, как вы уже знаете, по умолчанию ошибки выводятся туда же, куда и обычные данные.

Чтобы всё отработало как надо необходимо запустить скрипт так, чтобы вывод STDERR попадал в файл.

```bash
./myscript 2> myfile
```

Теперь обычный вывод отображается в консоли, а сообщения об ошибках попадают в файл.

### Постоянное перенаправление вывода
Если в скрипте нужно перенаправлять много выводимых на экран данных, добавлять соответствующую команду к каждому вызову ```echo``` неудобно. Вместо этого можно задать перенаправление вывода в определённый дескриптор на время выполнения скрипта, воспользовавшись командой ```exec```

```bash
exec 1> my.log

echo $(date) $USER
echo "Всё попадёт в файл"
```

Если просмотреть файл, указанный в команде перенаправления вывода, окажется, что всё, что
выводилось командами ```echo```, попало в этот файл.

Команду ```exec``` можно использовать не только в начале скрипта, но и в других местах

```bash
exec 2>> err.log
echo -e "[$(date)]\tError" >&2     # to STDERR
echo "Hello"                       # default to terminal STDOUT

exec 1>> my.log

for line in $(cat clients.csv)
do
    echo $line
done

echo "ERROR 127" >&2
echo "EOF"
```

```bash
1>filename
    # Перенаправление вывода (stdout) в файл "filename".
1>>filename
    # Перенаправление вывода (stdout) в файл "filename", файл открывается в режиме добавления.
2>filename
    # Перенаправление stderr в файл "filename".
2>>filename
    # Перенаправление stderr в файл "filename", файл открывается в режиме добавления.
&>filename
    # Перенаправление stdout и stderr в файл "filename"
```

## Перенаправление ввода в скриптах
Для перенаправления ввода можно воспользоваться той же методикой, которую применяли для перенаправления вывода. Команда ```exec``` позволяет сделать источником данных для STDIN какой-нибудь файл

```bash
exec 0< myfile
```

Эта команда указывает оболочке на то, что источником вводимых данных должен стать файл ```myfile```, а не обычный STDIN. 

```bash
exec 0< clients.csv

read line
echo -e "\t$line"

count=1

while read line
do
    echo "[$count] - $line"
    count=$(( $count + 1 ))
done
```

**Если перенаправить ввод, сделав источником данных файл, то команда ```read```, при попытке прочитать данные из STDIN, будет читать их из файла, а не с клавиатуры**.

Некоторые администраторы Linux используют этот подход для чтения и последующей обработки лог-файлов.

```bash
exec 0< access.log

grep "update" --color
```

## Создание собственного перенаправления вывода
Перенаправляя ввод и вывод в сценариях, вы не ограничены тремя стандартными дескрипторами файлов. Как уже говорилось, можно иметь до девяти открытых дескрипторов. Остальные шесть, с номерами от 3 до 8, можно использовать для перенаправления ввода или вывода. Любой из них можно назначить файлу и использовать в коде скрипта.

Назначить дескриптор для вывода данных можно, используя команду ```exec```

```bash
exec 3> my.log
#exec 3>> my.log

echo "File" $(date +"%T") >&3

echo "Terminal"
```

## Закрытие дескрипторов файлов
Оболочка автоматически закрывает дескрипторы файлов после завершения работы скрипта.

Однако, в некоторых случаях нужно закрывать дескрипторы вручную, до того, как скрипт закончит работу. Для того, чтобы закрыть дескриптор, его нужно перенаправить в ```&-```. 

```bash
# exec 2> err.log
exec 3> my.log
echo "File" $(date +"%T") >&3

exec 3>&-                           # close
echo "Not file" $(date +"%T") >&3   # error

echo "Terminal"
```

**После исполнения скрипта мы получим сообщение об ошибке**. Всё дело в том, что мы попытались обратиться к несуществующему дескриптору. 

## Подавление вывода
Иногда надо сделать так, чтобы команды в скрипте, который, например, может исполняться как фоновый процесс, ничего не выводили на экран. Для этого можно перенаправить вывод в ```/dev/null```. Это — что-то вроде «чёрной дыры».

```bash
ls -al badfile anotherfile 2> /dev/null
```

Тот же подход используется, если, например, надо очистить файл, не удаляя его

```bash
cat /dev/null > myfile
```

Подавление вывода на терминал

```bash
exec &> /dev/null
```

## Создание дескрипторов файлов для ввода данных
Перенаправить ввод в скрипте можно точно так же, как и вывод. Сохраните STDIN в другом дескрипторе, прежде чем перенаправлять ввод данных.

После окончания чтения файла можно восстановить STDIN и пользоваться им как обычно

```bash
exec 8<&0               # save 0 in 8 
exec 0< clients.csv     # STDIN from file

while read str
do
    echo ${str//;/" "}
done;

exec 0<&8               # 

read -p "Выйти? " answer

case $answer in
    y) echo "До свидание" ;;
    n) echo "Всё равно пока((" ;;
esac
```