# Урок 03. Shell. Переменные. Математика
[На главную](/mdk0401.github.io)

**Shell** - это командная оболочка. Но это не просто промежуточное звено между пользователем и операционной системой, это еще и мощный язык программирования. Программы на языке shell называют сценариями, или скриптами. Фактически, из скриптов доступен полный набор команд, утилит и программ UNIX. Если этого недостаточно, то к вашим услугам внутренние команды shell - условные операторы, операторы циклов и пр., которые увеличивают мощь и гибкость сценариев. Shell-скрипты исключительно хороши при программировании задач администрирования системы и др., которые не требуют для своего создания полновесных языков программирования.

## Sha-Bang #!
В простейшем случае, скрипт -- это ни что иное, как простой список команд системы, записанный в файл. Создание скриптов поможет сохранить ваше время и силы, которые тратятся на ввод последовательности команд всякий раз, когда необходимо их выполнить.

```bash
cd /var/log
cat /dev/null > messages
cat /dev/null > wtmp
cat /dev/null > access.log
```

Здесь нет ничего необычного, это простая последовательность команд, которая может быть набрана в командной строке. **Преимущество размещения последовательности команд в скрипте состоит в том, что вам не придется всякий раз набирать эту последовательность вручную.** Кроме того, скрипты легко могут быть модифицированы или обобщены для разных применений.

```bash
#!/bin/bash

cd /var/log
cat /dev/null > messages
cat /dev/null > wtmp
cat /dev/null > access.log

echo "Log files remove"
```

Если файл сценария начинается с последовательности ```#!```, которая в мире UNIX называется *sha-bang*, то это указывает системе какой интерпретатор следует использовать для исполнения сценария. Специальный маркер, определяющий тип сценария, в данном случае. Более точно, *sha-bang* определяет интерпретатор, который вызывается для исполнения сценария, это может быть командная оболочка (shell), иной интерпретатор или утилита. 

```
#!/bin/sh
#!/bin/bash
#!/usr/bin/perl
#!/usr/bin/tcl
#!/bin/sed -f
#!/usr/awk -f
```
Каждая, из приведенных выше сигнатур, приводит к вызову различных интерпретаторов, будь то ```#!/bin/sh``` - командный интерпретатор по-умолчанию и UNIX (bash для Linux-систем), либо иной. При переносе сценариев с сигнатурой ```#!/bin/sh``` на другие UNIX системы, где в качестве командного интерпретатора задан другой shell, вы можете лишиться некоторых особенностей, присущих bash.

## Запуск сценария
Запустить сценарий можно командой ```bash scriptname```. Более удобный вариант - сделать файл скрипта исполняемым, командой ```chmod```.

```bash
chmod u+x scriptname
```
 > [!WARNING]
 > Мы с Вами работаем с Cygwin на платформе Windows и данную команду выполнять нет необходимости. 

После того, как вы сделаете файл сценария исполняемым, вы можете запустить его примерно такой командой ```./scriptname```. Если, при этом, текст сценария начинается с корректной сигнатуры ("sha-bang"), то для его исполнения будет вызван соответствующий интерпретатор.

И наконец, завершив отладку сценария, вы можете поместить его в каталог /usr/local/bin (естественно, что для этого вы должны обладать правами root), чтобы сделать его доступным для себя и других пользователей системы. После этого сценарий можно вызвать, просто напечатав название файла в командной строке и нажав клавишу ```ENTER```.

> [!IMPORTANT]
> Другой вариант сделать скрипт доступным из любой точки системы добавить адрес каталога в переменную окружения ```PATH```

> [!NOTE]
> 1. Системные администраторы часто создают скрипты для автоматизации своего труда. Подумайте, для выполнения каких задач могут быть написаны сценарии.
> 1. Напишите сценарий, который выводит дату, время, имя пользователей и сохраняет эту информацию в файл.

## Зарезервированные слова
Зарезервированные слова - это слова, которые имеют особое значение для оболочки. Они используются для начала и завершения составных команд оболочки.
```
if  then  elif  else  fi 
time
for  in  until  while  do  done
case  esac  coproc  select  function
{ } [[ ]] !
```

> [!IMPORTANT]
> Так же в написании скриптов используются служебные символы. Перечень их достаточно большой. Более подробно мы их изучим позже.

## Управляющие символы
Изменяют поведение терминала или управляют выводом текста. Управляющий символ набирается с клавиатуры как комбинация ```CONTROL + <клавиша>```.

### Ctl-C
Завершение выполнения процесса.

### Ctl-D
Выход из командного интерпретатора (log out) (аналог команды exit).

### Ctl-G
"BEL" (звуковой сигнал -- "звонок").

### Ctl-L
Перевод формата (очистка экрана (окна) терминала). Аналогична команде clear.

### Ctl-U
Стирание строки ввода.

### Ctl-Z
Приостановка процесса.

## Пробельный символ
Используется как разделитель команд или переменных. В качестве пробельного символа могут выступать - **собственно пробел (space)**, **символ табуляции**, **символ перевода строки**, **символ возврата каретки** или комбинация из вышеперечисленных символов. В некоторых случаях, таких как присваивание значений переменным, использование пробельных символов недопустимо.

## Переменные
Переменные - это одна из основ любого языка программирования. Они участвуют в арифметических операциях, в синтаксическом анализе строк и совершенно необходимы для абстрагирования каких либо величин с помощью символических имен. Физически переменные представляют собой ни что иное как участки памяти, в которые записана некоторая информация.

```bash
var1=5
var2=23skidoo

echo $var1     # 5
echo $var2     # 23skidoo
```

Виды переменных в Bash:
+ переменные окружения
+ пользовательские(оболочки) переменные
+ локальные переменные

## Подстановка переменных
Символ ```$```, предшествующий имени переменной, указывает на то, что будет получено значение переменной.

Когда интерпретатор встречает в тексте сценария имя переменной, то он вместо него подставляет значение этой переменной. Поэтому **ссылки на переменные называются подстановкой переменных**.

Знак ```$``` 
Необходимо всегда помнить о различиях между именем переменной и ее значением. Если ```variable1``` - это имя переменной, то ```$variable1``` - это ссылка на ее значение. 

```bash
#!/bin/bash

# Присваивание значений переменным и подстановка значений переменных

a=375
hello=$a

#-------------------------------------------------
# Использование пробельных символов
# с обеих сторон символа "=" присваивания недопустимо.

#  Если записать "VARIABLE =value",
#+ то интерпретатор попытается выполнить команду "VARIABLE" с параметром "=value".

#  Если записать "VARIABLE= value",
#+ то интерпретатор попытается установить переменную окружения "VARIABLE" в ""
#+ и выполнить команду "value".
#-------------------------------------------------

echo hello    # Это не ссылка на переменную, выведет строку "hello".

echo $hello
echo ${hello} # Идентично предыдущей строке.

echo "$hello"
echo "${hello}kg"
```

> [!IMPORTANT]
> Примечательно, что написание ```$variable``` фактически является упрощенной формой написания ```${variable}```. Более строгая форма записи ```${variable}``` может с успехом использоваться в тех случаях, когда применение упрощенной формы записи порождает сообщения о синтаксических ошибках 


"Чистые" имена переменных, без префикса $, могут использоваться только при объявлении переменной, при присваивании переменной некоторого значения, при удалении (сбросе). Присваивание может производится с помощью символа ```=``` (например: ```var1=27```), инструкцией ```read``` и в заголовке цикла (```for var2 in 1 2 3```).

Заключение ссылки на переменную в двойные кавычки (" ") никак не сказывается на работе механизма подстановки. Этот случай называется "частичные кавычки", иногда можно встретить название "нестрогие кавычки". Одиночные кавычки (' ') заставляют интерпретатор воспринимать ссылку на переменную как простой набор символов, потому в одинарных кавычках операции подстановки не производятся. 

```bash
hello="A B  C   D"
echo $hello   # A B C D
echo "$hello" # A B  C   D
# Здесь вы сможете наблюдать различия в выводе echo $hello и echo "$hello".
# Заключение ссылки на переменную в кавычки сохраняет пробельные символы.

echo '$hello'  # $hello
# Внутри одинарных кавычек не производится подстановка значений переменных,
#+ т.е. "$" интерпретируется как простой символ.
```

```bash
numbers="один два три"
other_numbers="1 2 3"
# Если в значениях переменных встречаются пробелы,
# то использование кавычек обязательно.
echo "numbers = $numbers"
echo "other_numbers = $other_numbers"   # other_numbers = 1 2 3
echo

echo "uninitialized_variable = $uninitialized_variable"
# Неинициализированная переменная содержит "пустое" значение.
uninitialized_variable=   #  Объявление неинициализированной переменной
                          #+ (то же, что и присваивание пустого значения).
echo "uninitialized_variable = $uninitialized_variable"
                          # Переменная содержит "пустое" значение.

uninitialized_variable=23       # Присваивание.
unset uninitialized_variable    # Сброс.
echo "uninitialized_variable = $uninitialized_variable"
                                # Переменная содержит "пустое" значение.
```

## Присваивание значений переменным

### =
Оператор присваивания (пробельные символы до и после оператора недопустимы)

```bash
# Присваивание
a=879
echo "Значение переменной \"a\" - $a."
```

### Запись результата работы команды
Сделать это можно двумя способами:
+ С помощью значка обратного апострофа ```«`»```
+ С помощью конструкции ```$()```

```bash
a=`ls -l`         # В переменную 'a' записывается результат работы команды 'ls -l'
echo $a           # Кавычки отсутствуют, удаляются лишние пробелы и пустые строки.
echo
echo "$a"         # Переменная в кавычках, все пробелы и пустые строки сохраняются.
```

```bash
mydir=$(pwd)
echo $mydir
```

> [!IMPORTANT]
> Присваивание переменных с использованием ```$(...)``` более современный метод, по сравнению с обратными кавычками

### let
См. ниже

## Переменные Bash не имеют типа
В отличие от большинства других языков программирования, Bash не производит разделения переменных по "типам". По сути, переменные Bash являются **строковыми переменными**, но, в зависимости от контекста, Bash допускает целочисленную арифметику с переменными. Определяющим фактором здесь служит содержимое переменных.

```bash
n1=3
n2=5
sum=$n1+$n2

echo "Summ = $sum"    # Summ = 35
```

> [!WARNING]
> **Отсутствие типов** - это и благословение и проклятие. С одной стороны, отсутствие типов делает сценарии более гибкими и облегчает чтение кода. С другой, является источником потенциальных ошибок и поощряет привычку к "неряшливому" программированию.
> Бремя отслеживания типа той или иной переменной полностью лежит на плечах программиста. Bash не будет делать это за вас!

## Математические операции
В bash существует множество способов выполнения арифметических операций. В этой статье вы найдёте подробный обзор использования ```let```, ```expr```, ```(())``` и ```bc```.

### let
**let** - это встроенная функция bash, которая позволяет производить базовые арифметические операции.

```bash
# Простая арифметика с let

let A=5+4
echo $A           # 9

let "A = 5 + 4"   # допустимы пробелы
echo $A           # 9

let A++
echo $A           # 10

let "A = 4 * 5"
echo $A           # 20

B=90
let "A = $B + 30"
echo $A           # 120
```

| Оператор | Операция |
| :---: | :--- |
| +, -, \*, / |Сложение, вычитание, умножение, деление|
| ++ | Инкремент |	
| -- | Декремент |	
| % | Модуль: возвращает остаток от деления |	
	

### expr
**expr** похож на ```let``` за исключением того, что вместо сохранения результата в переменную ```expr``` **по умолчанию печатает ответ**.

Но никто не запрещает сохранять результат expr в переменные с помощью 
```bash
x=$(expr 2 + 2)   # 4
```

В отличие от ```let``` **не нужно заключать выражения с пробелами в кавычки**

```bash
#!/bin/bash
# Простая арифметика с использованием expr
C=5

expr 5 + 4      # 9

expr "5 + 4"    # 5 + 4

expr 5+4        # 5+4

expr 5 * $C     # 25

expr 11 % 2     # 1

A=$( expr 10 - 3 )
echo $A         # 7
```

> [!IMPORTANT]
> Нужно ставить пробелы вокруг операторов.

### Двойные круглые скобки
Для выполнения математических операций в файле скрипта можно использовать конструкцию вида
```$((a+b))```

```bash
var1=$(( 5 + 5 ))
echo $var1              # 10

var2=$(( $var1 * 2 ))
echo $var2              # 20

```

### Двойные круглые скобки 2
Эта конструкция во многом похожа на инструкцию ```let```, внутри ```((...))``` вычисляются арифметические выражения и возвращается их результат. В простейшем случае, конструкция ```a=$(( 5 + 3 ))``` присвоит переменной "a" значение выражения "5 + 3", или 8. Но, кроме того, двойные круглые скобки позволяют работать с переменными в стиле языка C.

```bash
# Работа с переменными в стиле языка C.

(( a = 23 ))  # Присвоение переменной в стиле C, с обоих сторон от "=" стоят пробелы.
echo "a (начальное значение) = $a"

(( a++ ))     # Пост-инкремент 'a', в стиле C.
echo "a (после a++) = $a"

(( a-- ))     # Пост-декремент 'a', в стиле C.
echo "a (после a--) = $a"

(( ++a ))     # Пред-инкремент 'a', в стиле C.
echo "a (после ++a) = $a"

(( --a ))     # Пред-декремент 'a', в стиле C.
echo "a (после --a) = $a"

echo

(( t = a<45?7:11 ))   # Трехместный оператор в стиле языка C.
echo "If a < 45, then t = 7, else t = 11."
echo "t = $t "        # Да!

# См. так же описание ((...))  в циклах "for" и "while".

# Эта конструкция доступна в Bash, начиная с версии 2.04.
```

## Целочисленное деление
В bash по умолчанию реализовано именно целочисленное деление

```bash
n1=3
n2=5

echo "summa = $(($n1 +   $n2))"
echo "mul = $(($n1 * $n2))"
echo "div = $(($n1 / $n2))"
echo "diff = $(($n1 - $n2))"
echo "module = $(($n2 % $n1))" # 2

echo "module = (($n2 % $n1))" # ошибка; ((..)) нельзя так использовать
```

## bc
Интерактивный интерпретатор Си-подобного языка, позволяет выполнять вычисления с произвольно заданной точностью. Часто используется как калькулятор в командной строке UNIX-подобных операционных систем.

> [!IMPORTANT]
> Необходимо дополнительно установить через инсталятор Cygwin

```bash
# сложение
X=1.5
Y=3.5

Z=$(bc<<<"scale=3;$X+$Y")
echo "1.5 + 3.5 = " $Z      # 5.0

# Деление с bc
A=100
B=3

D=$(bc<<<"scale=3;$A/$B")
echo "D: $D"                # 33.333

# Умножение с bc

A=2.5
B=5.6

С=$(bc<<<"scale=3;$A*$B")
echo "С: $C"                # 14.00
```