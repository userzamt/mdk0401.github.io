# Урок 22. Парсинг структурированных данных

[На главную](/mdk0401.github.io)

PowerShell может считывать, обновлять и удалять данные из множества источников. Это происходит благодаря встроенной поддержке любого объекта .NET и практически каждого метода оболочки. Если ваши данные хранятся в какой-то структурированной форме, то работать с ними будет еще проще.

## CSV-файлы 
Один из самых простых и распространенных способов хранения данных — использовать для этих целей *CSV-файл*. 

**CSV-файл** — это простой текстовый файл, в котором содержится таблица. Ее элементы разделены определенным общим символом — разделителем (чаще всего это запятые). У каждого CSV-файла основная структура одинакова: первая строка в CSV — это **строка заголовка**, содержащая все заголовки столбцов таблицы. В следующих строках находится содержимое таблицы. 

### Чтение CSV-файлов 
Из всех задач обработки CSV, которые может выполнять PowerShell, почти наверняка наиболее распространенной является чтение. Учитывая то, насколько **проста и эффективна структура CSV-файлов**, неудивительно, что они используются компаниями и приложениями во всем технологическом мире — отсюда и популярность команды PowerShell `Import-Csv`. 

Но что значит чтение CSV-файла? Хотя в нем есть вся необходимая информация, вы не можете импортировать ее прямо в программу. Обычно приходится читать файл и преобразовывать его в подходящие данные. Этот процесс называется **парсингом**. 

Команда `Import-Csv` парсит CSV-файл — считывает его, а затем преобразует данные в **объекты PowerShell**. 

```powershell
Get-Content .\materials_k_import.csv -Raw
```

Типичный CSV-файл состоит из строки заголовка и несколькими строками данных, разделенными на столбцы с помощью запятых. Обратите внимание, что прочитать файл можно с помощью командлета `Get-Content`. Так как CSV — это **текстовый файл**, команда `Get-Content` идеально подходит для его чтения (вообще-то это первый этап, происходящий с `Import-Csv`). 

Но также учтите, что команда `Get-Content` возвращает информацию в виде про- стой строки, что происходит при использовании параметра `-Raw`. В противном случае команда `Get-Content` возвращает **массив строк**, каждый элемент которого представляет строку в файле CSV

```powershell
$arr = Get-Content .\materials_k_import.csv
$arr.Count

$str = Get-Content .\materials_k_import.csv -Raw
$str.Length
```

Хотя команда `Get-Content` может считывать данные, она не понимает само устройство CSV-файла. Она понятия не имеет о том, что в таблице есть строки заголовка или данных, и не знает, что делать с разделителями. Команда просто принимает и выдает содержимое.

### Использование команды Import-Csv для обработки данных
`Import-Csv` читает файл CSV и выводит список пользовательских объектов PowerShell: один для каждой строки вводимых данных. PowerShell воспринимает **первую строку** файла CSV как **свойства объекта**, а последующие строки файла являются выводимыми объектами. 

```powershell
Import-Csv .\materials_k_import.csv

Import-Csv .\materials_k_import.csv | Format-Table
```

Первым делом бросается в глаза, что заголовки отделены линией от основных данных. Это означает, что команда Import-Csv считывает файл, обрабатывает верхнюю строку как строку заголовка и уже знает, как отделить ее от остального файла. 

Также заметно отсутствие запятых — когда команда читает и распознает CSV-файл, она знает, что разделитель используется для отделения элементов в таблице и не является частью ее данных. *Но что случится, если в коде появится другой разделитель?* 

```powershell
Import-Csv .\user.csv

Import-Csv .\user.csv -Delimiter ';'
```

