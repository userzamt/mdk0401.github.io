# Урок 11. Функции

[На главную](/mdk0401.github.io)

Подобно "настоящим" языкам программирования, Bash тоже имеет функции, хотя и в несколько ограниченном варианте. 

**Функция** - это подпрограмма, блок кода который реализует набор операций, своего рода "черный ящик", предназначенный для выполнения конкретной задачи. Функции могут использоваться везде, где имеются участки повторяющегося кода.

## Объявление функций
Функцию можно объявить несколькими способами

```bash
function function_name {
    command1
    ...
    commandN
}

# или

function_name () {
    command1
    ...
    commandN
}
```

Вторая форма записи ближе к сердцу C-программистам (она же более переносимая).

Как и в языке C, скобка, открывающая тело функции, может помещаться на следующей строке.

```bash
function_name ()
{
    command1
    ...
    commandN
}
```
Функцию можно вызвать без аргументов и с аргументами.

## Использование функций
Вызов функции осуществляется простым указанием ее имени в тексте сценария. Функцию можно вызывать столько раз, сколько нужно.

```bash
function msgHi() {
    echo "Hello from $$"
}

msgBay () {
    echo "Bay bay my $$"
}

msgHi
sleep 3
msgBay
```

Функция должна быть объявлена раньше, чем ее можно будет использовать. К сожалению, в Bash нет возможности "опережающего объявления" функции, как например в C.

```bash
funky   # error

funky () {
  echo "Это обычная функция."
} # Функция должна быть объявлена раньше, чем ее можно будет использовать.

# Вызов функции.
funky

exit 0
```

Придумывая имена для функций, учитывайте то, что они должны быть уникальными, иначе проблем не избежать. Если переопределить ранее объявленную функцию, новая функция будет вызываться вместо старой без каких-либо уведомлений или сообщений об ошибках.

```bash
whoami      # !!!!

whoami() {
    echo $USER
}

whoami      # ivanov

whoami() {
    echo "My name is $USER"
}

whoami      # My name is ivanov
```

Как видно, новая функция преспокойно затёрла старую и не только. 

> [!WARNING]
> Команда ```whoami``` выводит имя текущего пользователя. В результате предыдущего примера данная команда была затёрта функцией

## Код завершения
**Функции возвращают значение в виде кода завершения.** Код завершения может быть задан явно, с помощью команды ```return```, в противном случае будет возвращен код завершения **последней команды** в функции (0 - в случае успеха, иначе - ненулевой код ошибки). 

Код завершения в сценарии может быть получен через переменную ```$?```.

### ```return```
Завершает исполнение функции. Команда ```return``` может иметь необязательный аргумент типа *integer*, который возвращается в вызывающий сценарий как *"код завершения"* функции, это значение так же записывается в переменную ```$?```.

Есть два способа работы с тем, что является результатом вызова функции. Первый

```bash
function badSumm() {
    read -p "Введите два числа для сложения: " n1 n2
    return $(( $n1 + $n2 ))
}

badSumm
echo "Сумма = $?"
```

**Наибольшее положительное целое число, которое может вернуть функция - 255.** Команда ```return``` очень тесно связана с понятием код завершения, что объясняет это специфическое ограничение. К счастью существуют различные способы преодоления этого ограничения.

Если функция должна возвращать большее число или строку, понадобится другой подход.


## Запись вывода функции в переменную
Ещё один способ возврата результатов работы функции заключается в записи данных, выводимых функцией, в переменную. Такой подход позволяет обойти ограничения команды ```return``` и возвращать из функции любые данные.

```bash
sum() {
    read -p "Введите два числа для сложения: " n1 n2
    echo $(( $n1 + $n2 ))
}

result=$( sum )
echo "Ответ: $result"
```

## Аргументы функций
Функции могут принимать входные аргументы 

```bash
function_name $arg1 $arg2
```

Доступ к входным аргументам, в функциях, производится посредством позиционных параметров, т.е. `$1`, `$2` и так далее.

> [!NOTE]
> Например, имя функции хранится в параметре `$0`, первый переданный ей аргумент — в `$1`, второй — в `$2`, и так далее. Количество переданных функции аргументов можно узнать, обратившись к переменной `$#`.

```bash
div() {
    if [ -z "$1" -o -z "$2" ]
    then
        echo "ERROR 1. Вы не ввели число" >&2
        return 1
    fi

    echo $(bc<<<"scale=3; $1 / $2")
}

read -p "Введите два числа для деления: " m n
result=$( div $m $n )

echo "Результат деления = $result"
```

> [!NOTE]
> Команда `shift` вполне применима и к аргументам функций.

> [!IMPORTANT]
> В отличие от других языков программирования, в сценариях на языке командной оболочке, в функции передаются аргументы по значению. Если имена переменных (которые фактически являются указателями) передаются функции в виде аргументов, то они интерпретируются как обычные строки символов и не могут быть разыменованы. Функции интерпретируют свои аргументы буквально.

Обратите внимание на то, что функция не может напрямую работать с параметрами, которые переданы скрипту при его запуске из командной строки.

```bash
function myfunc {
    echo $(( $1 + $2 )) # error
}

if [ $# -eq 2 ]
then
    value=$( myfunc)
    echo "The result is $value"
else
    echo "Usage: myfunc  a b"
fi
```

Вместо этого, если в функции планируется использовать параметры, переданные скрипту при вызове из командной строки, надо передать их ей при вызове.

## Работа с переменными в функциях
Переменные, объявленные внутри функций, ведут себя не так, как те переменные, с которыми мы уже сталкивались. Они могут быть скрыты от других частей скриптов.

Существуют два вида переменных:

+ Глобальные переменные.
+ Локальные переменные.

### Глобальные переменные
**Глобальные переменные** — это переменные, которые видны из любого места bash-скрипта. Если вы объявили глобальную переменную в основном коде скрипта, к такой переменной можно обратиться из функции.

Почти то же самое справедливо и для глобальных переменных, **объявленных в функциях**. Обращаться к ним можно и в основном коде скрипта после вызова функций.

По умолчанию **все объявленные в скриптах переменные глобальны**. Так, к переменным, объявленным за пределами функций, можно без проблем обращаться из функций

```bash
func() {
    myname="Ivanov Ivan Ivanovich"
    age=39

    echo -e "Fio: $myname \nAge: $age"
}

func
echo

myname=$myname+"2"
echo $myname
```

Переменные, объявляемые в теле функции, считаются необъявленными до тех пор, пока функция не будет вызвана. Это касается всех переменных.

```bash
# переменная будет считаться необъявленной
# до тех пор, пока функция не будет вызвана
func () {
    global_var=37   
}

# функция "func" еще не была вызвана,
# поэтому $global_var пока еще не "видна" здесь
echo "global_var = $global_var" 

func
echo "global_var = $global_var"  # global_var = 37
```

### Локальные переменные
Переменные, которые объявляют и используют внутри функции, могут быть объявлены локальными. Для того, чтобы это сделать, используется ключевое слово `local` перед именем переменной

```bash
local var="value"
```
Если за пределами функции есть переменная с таким же именем, это на неё не повлияет. Ключевое слово local позволяет отделить переменные, используемые внутри функции, от остальных переменных. 

```bash
func () {
    local var=39   # локальная для блока функции
}

func
echo "var = $var"  # ""

var="40"
echo "var = $var"  # 40
```

## Передача функциям массивов в качестве аргументов
Попробуем передать функции в качестве аргумента массив. Сразу хочется сказать, что работать такая конструкция будет неправильно

```bash
sort() {
    echo $1 $2 $3
    echo $@;
}

arr=(a b c d e f)
sort $arr
```

При передаче функции массива, она получит доступ лишь к его первому элементу.

Для того, чтобы эту проблему решить, из массива надо извлечь имеющиеся в нём данные и передать их функции как самостоятельные аргументы. Если надо, внутри функции полученные ей аргументы можно снова собрать в массив

```bash
sort() {
    echo $1 $2 $3
    echo $@;
}

arr=(a b c d e f)
sort ${arr[@]}
```

```bash
sort() {
    local arr=( $@ )
    echo "Local arr( ${arr[*]} )"
}

arr=(a b c d e f)
sort ${arr[@]}
```

## Создание и использование библиотек
Оболочка bash позволяет создавать так называемые библиотеки — файлы, содержащие функции, а затем использовать эти библиотеки в любых скриптах, где они нужны.

Ключ к использованию библиотек — в команде `source`. Эта команда используется для подключения библиотек к скриптам. В результате функции, объявленные в библиотеке, становятся доступными в скрипте, в противном же случае функции из библиотек не будут доступны в области видимости других скриптов.

У команды `source` есть псевдоним — оператор *«точка»*. Для того, чтобы подключить файл в скрипте, в скрипт надо добавить конструкцию такого вида

```bash
source FILENAME [ARGUMENTS]
. FILENAME [ARGUMENTS]
```


Предположим, что у нас имеется файл, который содержит следующее

```bash
#!/bin/bash

check_root () {
  if [[ $EUID -ne 0 ]]; then
    echo "This script must be run as root" 
    exit 1
  fi
}
```

Это — библиотека. Воспользуемся ей в сценарии

```bash
source ./function.sh

check_root

echo "I am root"
exit 0
```

Если вы запустите приведенный выше скрипт от имени пользователя без прав *root*, он выведет *"This script must be run as root"* и завершит работу.

Преимущество такого подхода заключается в том, что ваши скрипты будут меньше по размеру и более удобочитаемы, вы сможете повторно использовать один и тот же файл функции всякий раз, когда это необходимо, а в случае, если вам нужно изменить функцию, вы отредактируете только один файл.