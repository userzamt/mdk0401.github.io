# Урок 08. Параметры и ключи командной строки
[На главную](/mdk0401.github.io)

Наиболее распространённый способ передачи данных сценариям заключается в использовании параметров командной строки. Вызвав сценарий с параметрами, мы передаём ему некую информацию, с которой он может работать. 

```bash
$ ./myfunc.sh 10 20
```

В данном примере сценарию передано два параметра — ```10``` и ```20```. Всё это хорошо, но как прочесть
данные в скрипте?

## Чтение параметров командной строки
Оболочка bash назначает специальным переменным, называемым позиционными параметрами, введённые при вызове скрипта параметры командной строки:

+ ```$0``` — имя скрипта.
+ ```$1``` — первый параметр.
+ ```$2``` — второй параметр — и так далее, вплоть до переменной ```$9```, в которую попадает девятый
параметр.

> [!IMPORTANT]
> Если скрипту надо больше девяти параметров, при обращении к ним номер в имени переменной надо заключать в фигурные скобки
> ```${10}```

```bash
# запустите скрипт с указанием параметров(через пробелы) после его имени
echo $0
echo $1
echo $2 
```

```bash
if [ -n "$1" ] && [ -n "$2" ]
then
    # summ=$[ $1 + $2 ] # old 
    summ=$(( $1 + $2 )) # new version 

    echo $summ
else
    exit 1  # exit with error
fi
```

Параметры командной строки не обязательно должны быть числами. Сценариям можно передавать и строки.

```bash
# изменим вывод результат из прошлого примера
echo "$1 + $2 = $summ"
```

Что если параметр содержит пробелы, а нам надо обрабатывать его как самостоятельный фрагмент данных? **Необходимо использовать кавычки**.

```bash
$ ./myfunc.sh "Иванов Иван Иванович"
# $1 = "Иванов Иван Иванович"
```

Вариант со *"значением по умолчанию"*

```bash
# см. лекцию по строкам
user=${1-"root"}  # default user name

echo "User - $user"
```

## Работа с параметрами
В скрипте можно подсчитать количество переданных ему параметров. Оболочка bash предоставляет для этого специальную переменную. А именно, переменная ```$#``` содержит количество параметров, переданных сценарию при вызове.

```bash
$ ./myfunc.sh Иванов Иван Иванович
```

```bash
echo "Количество переданных параметров - $#"
```
Эта переменная даёт необычный способ получения последнего из переданных скрипту параметров, не требующий знания их количества.

```bash
echo "Последний параметр имеет значение - ${!#}"
```

В некоторых случаях нужно захватить все параметры, переданные скрипту. Для этого можно воспользоваться переменными ```$*``` и ```$@```. Обе они содержат все параметры командной строки, что делает возможным доступ к тому, что передано сценарию, без использования позиционных
параметров.

Переменная ```$*``` содержит все параметры, введённые в командной строке, в виде единого «слова».

В переменной ```$@``` параметры разбиты на отдельные «слова». Эти параметры можно перебирать в циклах.

```bash
list=$@
str=$*

echo $list
echo $str

echo "For \$@"
for var in "$@"
do
    echo -e "\t$var"
done

echo "For \$*"
for var in "$*"
do
    echo -e "\t$var"
done
```

Переменная ```$*``` содержит все переданные скрипту параметры как единый фрагмент данных, в то время как в переменной ```$@``` они представлены самостоятельными значениями. Какой именно переменной воспользоваться — зависит от того, что именно нужно в конкретном сценарии.


## ```shift```
На операционных системах семейства Unix (Linux, FreeBSD и т. п.) в bash работает команда ```shift```. Когда она выполняется, происходит сдвиг влево позиционных параметров скрипта (т. е. аргументов командной строки, переданных в скрипт). Каждый из параметров помещается в более младшую относительно текущей позицию.

```bash
shift [n]
```

Когда вы запускаете ```shift n```, текущие позиционные параметры сдвигаются влево n раз. Позиционный параметр x получает значение позиционного параметра x+n. Если параметр x+n не существует, то параметр x становится неустановленным.

Если величина сдвига ```n``` для команды ```shift``` не указана, то применяется значение по умолчанию 1. Таким образом, команды shift 1 и shift без аргумента делают одно и то же.

Если параметр сдвигается в позицию, которая меньше 1, то он выбрасывается, т. е. его значение теряется. Так что, к примеру, команда ```shift``` будет всегда выбрасывать предыдущее значение ```$1```, и ```shift 2``` всегда выбросит предыдущие значения ```$1``` и ```$2```.

Специальный позиционный параметр ```$0``` исключается из операций ```shift```, и он всегда остается доступным, на него команда ```shift``` не влияет.

```bash
len=$#

# for ((i=0; i < $#; i++))
# for ((i=0, len=$#; i < $#; i++))
for ((i=0; i <= len; i++))
do
    echo -e "\nIteration $i"
    echo "--------------------"
    echo "\$1 = $1"
    shift
    sleep 1
done
```

> [!WARNING]
> Используя команду ```shift```, помните о том, что при каждом её вызове значение переменной ```$1``` безвозвратно теряется.

## ```case```
Инструкции ```case``` и ```select``` технически не являются циклами, поскольку не предусматривают многократное исполнение блока кода. Однако, они, как и циклы, управляют ходом исполнения программы, в зависимости от начальных или конечных условий.

```bash
case "$variable" in

    "$condition1" )
        command1
        ...
        commandN
    ;;

    "$condition2" )
        command1
        ...
        commandN
     ;;

esac
```

Конструкция ```case``` эквивалентна конструкции switch в языке C/C++. Она позволяет выполнять тот или иной участок кода, в зависимости от результатов проверки условий. Она является, своего рода, краткой формой записи большого количества операторов if/then/else и может быть неплохим инструментом при создании разного рода **меню**.

**Важно**

+ Заключать переменные в кавычки необязательно, поскольку здесь не производится разбиения на отдельные слова.

+ Каждая строка с условием должна завершаться правой (закрывающей) круглой скобкой ```)```.

+ Каждый блок команд, отрабатывающих по заданному условию, должен завершаться двумя символами точка-с-запятой ```;;```.

+ Блок ``case`` должен завершаться ключевым словом ``esac`` (case записанное в обратном порядке).

```bash
num=$(( $RANDOM % 10 ))

case $num in

    2) 
        echo "Num = 2"
    ;;

    8 ) echo "Octonumber)))";;

    *) echo $num ;;
esac
```

Допускается указывать диапазоны символов в [квадратных скобках]

```bash
key=" "

case "$key" in
  [a-z]) echo "буква в нижнем регистре";;
  [A-Z]) echo "Буква в верхнем регистре";;
  [0-9]   ) echo "Цифра";;
  *       ) echo "Знак пунктуации, пробел или что-то другое";;
```

```bash
echo -n "Хотите поиграть?(Да/Нет): "
read answer

case $answer in 
    Д | Да | д | да | Yes | yes | Y | y )
        echo "Ура!! Мы играем"
    ;;

    Н|Нет|н|нет|No|no|N|n )
        echo "Очень жаль(( До свидания"
    ;;

    *) echo "Мне не понятен Ваш ответ"; echo ; answer="" ;;
esac
```

## Ключи командной строки
Ключи командной строки обычно выглядят как буквы, перед которыми ставится тире. Они служат для управления сценариями. 

```bash
while [ -n "$1" ]
do
  case "$1" in
    -a) echo "Find $1" ;;
    -b) echo "Find $1" ;;
    -c) echo "Find $1" ;;
    -d) echo "Find $1" ;;
    *) echo "Not found key $1"; exit 1 ;;
  esac

  shift

done
# echo $?
```

В этом коде использована конструкция ```case```, которая сверяет переданный ей ключ со списком обрабатываемых скриптом ключей. Если переданное значение нашлось в этом списке, выполняется соответствующая ветвь кода. Если при вызове скрипта будет использован ключ, обработка
которого не предусмотрена, будет выполнена ветвь ```*)```.

## Обработка ключей со значениями
По мере усложнения ваших скриптов, вы столкнётесь с ситуациями, когда обычных ключей уже недостаточно, а значит, нужно будет использовать ключи с некими значениями. 

```bash
$ ./myfunc.sh -u root -h 10.207.106.52 -p --port 3306
```

```bash
passwd=

while [ -n "$1" ]
do
  case "$1" in
    -u)
      echo "User - $2"
      shift
    ;;

    -h)
      echo "Host - $2"
      shift
    ;;

    -p) 
      read passwd
    ;;

    --port)
      echo "Port - $2"
      shift 
    ;;

    *) echo "Not found key $1"; exit 1 ;;
  esac

  shift

done

echo "Вы ввели пароль - $passwd"
```

Так как обрабатываемый ключ находится в переменной ```$1```, соответствующий ему параметр будет находиться в ```$2``` (тут используется команда ```shift```, поэтому, по мере обработки, всё, что передано сценарию, сдвигается влево). Остается лишь извлечь значение переменной ```$2``` и у нас будет параметр нужного ключа. Конечно, тут
понадобится ещё одна команда shift для того, чтобы следующий ключ попал в ```$1```.

## Стандартные ключи
При написании bash-скриптов вы можете выбирать любые буквы для ключей командной строки и произвольно задавать реакцию скрипта на эти ключи. Однако, в мире Linux значения некоторых ключей стали чем-то вроде стандарта, которого полезно придерживаться. 

| Ключ | Описание |
| :--: | :-- |
|-a| Вывести все объекты.
|-c| Произвести подсчёт.
|-d| Указать директорию.
|-e| Развернуть объект.
|-f| Указать файл, из которого нужно прочитать данные.
|-h| Вывести справку по команде.
|-i| Игнорировать регистр символов.
|-l| Выполнить полноформатный вывод данных.
|-n| Использовать неинтерактивный (пакетный) режим.
|-o| Позволяет указать файл, в который нужно перенаправить вывод.
|-q| Выполнить скрипт в quiet-режиме.
|-r| Обрабатывать папки и файлы рекурсивно.
|-s| Выполнить скрипт в silent-режиме.
|-v| Выполнить многословный вывод.
|-x| Исключить объект.
|-y| Ответить «yes» на все вопросы.

Если вы работаете в Linux, вам, скорее всего, знакомы многие из этих ключей. Использовав их в общепринятом значении в своих скриптах, вы поможете пользователям взаимодействовать с ними, не беспокоясь о чтении документации.

## Получение данных от пользователя
Ключи и параметры командной строки — это отличный способ получить данные от того, кто пользуется скриптом, однако в некоторых случаях нужно больше интерактивности.

Иногда сценарии нуждаются в данных, которые пользователь должен ввести во время выполнения программы. Именно для этой цели в оболочке bash имеется команда ```read```.

**Эта команда позволяет принимать введённые данные либо со стандартного ввода (с клавиатуры), либо используя другие дескрипторы файлов**. После получения данных, эта команда помещает их в переменную

```bash
echo -n "Введите логин: "
read login                  # создаться 

echo "Добро пожаловать $login"
```

```bash
echo -n "ФИО: "
read lastname firstname surname

echo "Фамилия - $lastname"
echo "Имя - $firstname"
echo "Отчество - $surname"
```

Вместе с командой ```read``` можно вывести приглашение для ввода ```-p```

```bash
read -p "Продолжить выполнение скрипта(y/n)?" answer

case $answer in
    y) echo "Let's go" ;;
    n) echo "bay(((" ;;
esac
```

Если, вызвав ```read```, не указывать переменную, данные, введённые пользователем, будут помещены в специальную переменную среды ```REPLY```

```bash
read -p "Продолжить выполнение скрипта(y/n)?"

case $REPLY in
    y) echo "Let's go" ;;
    n) echo "bay(((" ;;
esac
```

Если скрипт должен продолжать выполнение независимо от того, введёт пользователь какие-то данные или нет, вызывая команду read можно воспользоваться ключом -t. Ключ задаёт время ожидания ввода в секундах

```bash
read -p "Продолжить выполнение скрипта(y/n)?" -t 5
echo

case ${REPLY:-"y"} in
    y) echo "Let's go" ;;
    n) echo "bay(((" ;;
esac
```

Иногда то, что вводит пользователь в ответ на вопрос скрипта, лучше на экране не показывать.

Например, так обычно делают, запрашивая пароли. Ключ ```-s``` команды ```read``` предотвращает отображение на экране данных, вводимых с клавиатуры. На самом деле, данные выводятся, но команда ```read``` **делает цвет текста таким же, как цвет фона**

```bash
read -p "Логин: " 
login=$REPLY

read -p "Пароль: " -s
passwd=$REPLY

echo "$login / $passwd"
```

Команда ```read``` может, при каждом вызове, читать одну строку текста из файла. Когда в файле больше не останется непрочитанных строк, она просто остановится. Если нужно получить в скрипте всё содержимое файла, можно, с помощью **конвейера**, передать результаты вызова команды ```cat``` для файла, конструкции ```while```, которая содержит команду ```read``` 

```bash
count=0

cat clients.csv | while read str
do
    echo $((count++)) $str
done
```

Тут передали в цикл ```while``` содержимое файла и перебрали все строки этого файла, выводя номер и содержимое каждой из них.