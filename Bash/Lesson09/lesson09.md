# Урок 09. Ввод и вывод
[На главную](/mdk0401.github.io)

Иногда что-то надо показать на экране, а что-то — записать в файл, поэтому нужно разобраться с тем, как в Linux обрабатывается ввод и вывод, а значит — научиться отправлять результаты работы сценариев туда, куда нужно. 

## Стандартные дескрипторы файлов
Всё в Linux — это файлы, в том числе — ввод и вывод. Операционная система идентифицирует файлы с использованием дескрипторов.

**Дескриптор файла** - это просто число, по которому система идентифицирует открытые файлы. Рассматривайте его как упрощенную версию указателя на файл.

**Файловые дескрипторы** - это способ, которым программы ссылаются на файлы или на другие ресурсы, которые работают как файлы (такие как каналы, устройства, сокеты или терминалы). Это что-то вроде указателей на источники данных или места, куда могут быть записаны/считаны данные. 

По умолчанию каждый новый процесс начинается с трех открытых дескрипторов

+ 0, STDIN — стандартный поток ввода
+ 1, STDOUT — стандартный поток вывода
+ 2, STDERR — стандартный поток ошибок

Каждому процессу позволено иметь до **девяти** открытых дескрипторов файлов. Оболочка bash резервирует первые три дескриптора с идентификаторами ```0```, ```1``` и ```2```

> [!IMPORTANT]
>  Иногда дополнительные дескрипторы могут сослужить неплохую службу, временно сохраняя в себе ссылку на stdin, stdout или stderr. Это упрощает возврат дескрипторов в нормальное состояние после сложных манипуляций с перенаправлением и перестановками

В интерактивной оболочке или в скрипте, запущенном на терминале, стандартный ввод - это символы, которые вы вводите на клавиатуре. Стандартный вывод - это то, куда программа отправляет большую часть своей обычной информации, чтобы пользователь мог ее увидеть(окно терминала), а стандартная ошибка - это то, куда программа отправляет свои сообщения об ошибках.

Приложения с графическим интерфейсом также имеют эти дескрипторы, но обычно они с ними не работают. Обычно они осуществляют все свое взаимодействие с пользователем через графический интерфейс.

В соответствии с соглашениями, команды принимают ввод из файла с дескриптором 0 (stdin), выводят результат работы в файл с дескриптором 1 (stdout), а сообщения об ошибках в файл с дескриптором 2 (stderr). 

Эти три специальных дескриптора обрабатывают ввод и вывод данных в сценарии. Вам нужно как следует разобраться в стандартных потоках. Их можно сравнить с фундаментом, на котором строится взаимодействие скриптов с внешним миром. 

## STDIN
**STDIN** — это стандартный поток ввода оболочки. Для терминала стандартный ввод — это клавиатура.

Когда в сценариях используют символ перенаправления ввода — ```<```, Linux заменяет дескриптор файла стандартного ввода на тот, который указан в команде. Система читает файл и обрабатывает данные так, будто они введены с клавиатуры.

```bash
wc < file.txt
```

```bash
wc <<< "Hello world"
```

> [!IMPORTANT]
> Если входной файл не задан, то данные считываются со стандартного ввода. При выводе, в первой колонке содержится количество строк, во второй — слов, в третьей — символов.

```bash
bc <<< 85*96
```

Многие команды bash принимают ввод из STDIN, если в командной строке не указан файл, из которого надо брать данные. 

Например, это справедливо для команды ```cat```. Когда вы вводите команду ```cat``` в командной строке, не задавая параметров, она принимает ввод из STDIN. После того, как вы вводите очередную строку, ```cat``` просто выводит её на экран.

```bash
cat
```

## STDOUT
**STDOUT** — стандартный поток вывода оболочки. По умолчанию это — экран. 

### COMMAND_OUTPUT >
Перенаправление stdout (вывода) в файл.

Если файл отсутствовал, то он создается, иначе перезаписывается.

```bash
ls -lR > dir-tree.list
# Создает файл, содержащий список дерева каталогов.

: > filename
# Операция > усекает файл "filename" до нулевой длины.
# Если до выполнения операции файла не существовало,
# то создается новый файл с нулевой длиной (тот же эффект дает команда 'touch').
# Символ : выступает здесь в роли местозаполнителя, не выводя ничего.

> filename
# Операция > усекает файл "filename" до нулевой длины.
# Если до выполнения операции файла не существовало,
# то создается новый файл с нулевой длиной (тот же эффект дает команда 'touch').
# (тот же результат, что и выше - ": >", но этот вариант неработоспособен
# в некоторых командных оболочках.)

/dev/null > filename
```

### >>
Большинство bash-команд выводят данные в STDOUT, что приводит к их появлению в консоли. Данные можно перенаправить в файл, присоединяя их к его содержимому, для этого служит команда ```>>```.

Итак, у нас есть некий файл с данными, к которому мы можем добавить другие данные с помощью этой команды:

```bash
pwd >> myfile
```

То, что выведет pwd, будет добавлено к файлу ```myfile```, при этом уже имеющиеся в нём данные никуда не денутся.

Что будет если попытаться выполнить что-то вроде показанного выше, обратившись к несуществующему файлу (например nonexistentfile.txt)

```bash
cat clients.csv >>> nonexistentfile.txt
```

После выполнения этой команды мы увидим сообщения об ошибках на экране.

При попытке обращения к несуществующему файлу генерируется ошибка, но оболочка не перенаправила сообщения об ошибках в файл, выведя их на экран. Но что если мы хотим, чтобы сообщения
об ошибках попали в файл?




