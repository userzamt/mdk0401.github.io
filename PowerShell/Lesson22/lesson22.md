# Урок 22. Парсинг структурированных данных

[На главную](/mdk0401.github.io)

PowerShell может считывать, обновлять и удалять данные из множества источников. Это происходит благодаря встроенной поддержке любого объекта .NET и практически каждого метода оболочки. Если ваши данные хранятся в какой-то структурированной форме, то работать с ними будет еще проще.

## CSV-файлы 
Один из самых простых и распространенных способов хранения данных — использовать для этих целей *CSV-файл*. 

**CSV-файл** — это простой текстовый файл, в котором содержится таблица. Ее элементы разделены определенным общим символом — разделителем (чаще всего это запятые). У каждого CSV-файла основная структура одинакова: первая строка в CSV — это **строка заголовка**, содержащая все заголовки столбцов таблицы. В следующих строках находится содержимое таблицы. 

### Чтение CSV-файлов 
Из всех задач обработки CSV, которые может выполнять PowerShell, почти наверняка наиболее распространенной является чтение. Учитывая то, насколько **проста и эффективна структура CSV-файлов**, неудивительно, что они используются компаниями и приложениями во всем технологическом мире — отсюда и популярность команды PowerShell `Import-Csv`. 

Но что значит чтение CSV-файла? Хотя в нем есть вся необходимая информация, вы не можете импортировать ее прямо в программу. Обычно приходится читать файл и преобразовывать его в подходящие данные. Этот процесс называется **парсингом**. 

Команда `Import-Csv` парсит CSV-файл — считывает его, а затем преобразует данные в **объекты PowerShell**. 

```powershell
Get-Content .\materials_k_import.csv -Raw
```

Типичный CSV-файл состоит из строки заголовка и несколькими строками данных, разделенными на столбцы с помощью запятых. Обратите внимание, что прочитать файл можно с помощью командлета `Get-Content`. Так как CSV — это **текстовый файл**, команда `Get-Content` идеально подходит для его чтения (вообще-то это первый этап, происходящий с `Import-Csv`). 

Но также учтите, что команда `Get-Content` возвращает информацию в виде про- стой строки, что происходит при использовании параметра `-Raw`. В противном случае команда `Get-Content` возвращает **массив строк**, каждый элемент которого представляет строку в файле CSV

```powershell
$arr = Get-Content .\materials_k_import.csv
$arr.Count

$str = Get-Content .\materials_k_import.csv -Raw
$str.Length
```

Хотя команда `Get-Content` может считывать данные, она не понимает само устройство CSV-файла. Она понятия не имеет о том, что в таблице есть строки заголовка или данных, и не знает, что делать с разделителями. Команда просто принимает и выдает содержимое.

### Использование команды Import-Csv для обработки данных
`Import-Csv` читает файл CSV и выводит список пользовательских объектов PowerShell: один для каждой строки вводимых данных. PowerShell воспринимает **первую строку** файла CSV как **свойства объекта**, а последующие строки файла являются выводимыми объектами. 

```powershell
Import-Csv .\materials_k_import.csv

Import-Csv .\materials_k_import.csv | Format-Table
```

Первым делом бросается в глаза, что заголовки отделены линией от основных данных. Это означает, что команда Import-Csv считывает файл, обрабатывает верхнюю строку как строку заголовка и уже знает, как отделить ее от остального файла. 

Также заметно отсутствие запятых — когда команда читает и распознает CSV-файл, она знает, что разделитель используется для отделения элементов в таблице и не является частью ее данных. *Но что случится, если в коде появится другой разделитель?* 

```powershell
Import-Csv .\user.csv

Import-Csv .\user.csv -Delimiter ';'
```

### Превращение сырых данных в объекты 
Команда `Import-Csv` не просто считывает CSV-файл и выводит его с необычным форматированием. Содержимое файла помещается в массив `PSCustomObjects`. Здесь каждый объект `PSCustomObject` содержит данные одной строки. У каждого объекта есть **свойства, соответствующие заголовкам строки**. Если же вам нужны данные из столбца этого заголовка, достаточно лишь обратиться к этому свойству. Зная всего лишь какой вид данных следует ожидать, команда `Import-Csv` может взять прежде неизвестную строку и превратить ее в простые и удобные объекты. 

Данные в виде массива `PSCustomObjects` позволяют вам использовать их гораздо эффективнее. Допустим, вы хотите найти только сотрудников с фамилией *Маслов*. Поскольку каждая строка данных в CSV является объектом `PSCustomObject`, вы можете сделать это с помощью команды `Where-Object`

```powershell
 Import-Csv .\user.csv -Delimiter ';' | Where-Object {$_.'Фамилия' -eq 'Маслов'} | Format-Table
```

```powershell
Import-Csv .\materials_k_import.csv | Where-Object {$_.'Наименование материала' -like '*нить*'} | Format-Table
```

### Определяем собственный заголовок 
*Что делать, если у вас есть таблица данных, но вы хотите сделать строку за- головка более удобной для пользователя?* Команда `Import-Csv` справится и с этим. Как и в случае с новым разделителем, ей достаточно просто передать параметр. Параметр `Header` используется для передачи серии строк, разделенных запятыми (новых заголовков).

```powershell
Import-Csv .\materials_k_import.csv -Header "Name","Type","Img","Cost","CountOnStorage","MinCount","CountOnPackage","Unit"

Import-Csv .\materials_k_import.csv -Header "Name","Type","Img","Cost","CountOnStorage","MinCount","CountOnPackage","Unit" | Format-Table

Import-Csv .\materials_k_import.csv -Header "Name","Type","Img","Cost","CountOnStorage","MinCount","CountOnPackage","Unit" | Select-Object -Skip 1 | Format-Table
```

### Создание CSV-файлов 
Вы можете написать CSV-файл от руки, но это потребует немалых затрат времени и энергии, особенно если речь идет о тысячах строк. К счастью, у PowerShell есть собственный командлет для создания CSV-файлов — `Export-Csv`. Его можно использовать для создания CSV-файлов **из любого существующего объекта** PowerShell. Вам достаточно указать, какие объекты использовать в качестве строк и где должен быть создан файл. 

Давайте предположим, что вы хотите запросить все запущенные на вашем компьютере процессы и записать их название, издателя и описание. Можно использовать команду `Get-Process` и `Select-Object`, чтобы ограничить список свойств

```powershell
Get-Process | Sort-Object -Descending WS | Select-Object -First 10 -Property Id, Name, WS, Company, Description
```

Сохранении вывода с помощью `Export-Csv`

```powershell
Get-Process | Sort-Object -Descending WS | Select-Object -First 10 -Property Id, Name, WS, Company, Description | Export-Csv HeavyProcess.csv -NoTypeInformation

Get-Content .\HeavyProcess.csv
```

> [!IMPORTANT]
> Параметр `NoTypeInformation` не является обязательным, но, если вы его не используете, в верхней строке вашего CSV-файла будет указан тип объекта, из которого он был получен. Если вы повторно импортируете CSV-файл обратно в PowerShell, это будет вам мешать. Строка выглядит примерно как *#TYPE Selected.System.Diagnostics.Process*.

> [!NOTE]
> Вам так же доступен параметр `Delimiter` для указаниям символа разделителя. По умолчанию используется запятая *,*

## Данные в формате JSON 
**JSON** (*англ. JavaScript Object Notation*, представление объектов JavaScript) - текстовый формат обмена данными, основанный на JavaScript. Как и многие другие текстовые форматы, JSON легко читается людьми. Формат JSON был разработан Дугласом Крокфордом.

JSON - текстовый формат, полностью независимый от языка реализации, но он использует соглашения, знакомые программистам C-подобных языков, таких как C, C++, C#, Java, JavaScript, Perl, Python и многих других. Эти свойства делают JSON идеальным языком **обмена данными**.

Наиболее частое распространенное использование JSON - **пересылка данных от сервера к браузеру**. Обычно данные JSON доставляются с помощью AJAX, который позволяет обмениваться данными браузеру и серверу без необходимости перезагружать страницу.

Как следует из названия, такое представление данных активно использовалось в приложениях JavaScript, а следовательно, и в веб-разработке. Недавний всплеск числа онлайн-сервисов, пользующихся **REST API** (это технология, которую используют для передачи данных между клиентом и сервером), привел к параллельному всплеску использования JSON. 

### Чтение данных в формате JSON 
Подобно чтению CSV-файлов, вы можете считать JSON-файлы в PowerShell двумя способами: с анализом или без него. Поскольку JSON — это простой текст, PowerShell по умолчанию обрабатывает его как строку.

```powershell
Get-Content .\emojis.json -Raw
```

Но со строкой можно мало что сделать. Нужна какая-то структура. Для этого вам понадобится нечто, что понимает устройство JSON (точнее, способ представления отдельных узлов и их массивов в JSON), а также может анализировать файлы соответствующим образом. Вам понадобится командлет `ConvertFrom-Json`. 

`ConvertFrom-Json` — это встроенный командлет PowerShell, который принимает на вход необработанный JSON и преобразует его в объекты PowerShell. 

```powershell
Get-Content .\emojis.json | ConvertFrom-Json
```

Если вы посмотрите на атрибут *emojis*, то увидите, что все узлы были проанализированы, причем каждый ключ — это заголовок столбца, а каждое значение представляет значение строки

```powershell
(Get-Content .\emojis.json | ConvertFrom-Json).emojis | Select-Object -First 10 | Format-Table

(Get-Content .\emojis.json | ConvertFrom-Json).emojis[0]
```

Атрибут *emojis* теперь представляет собой массив объектов, которые можно запрашивать и с которыми можно работать, — в общем, работать с ним можно, как и с любым другим массивом.

### Создание строк JSON 
*Допустим, у вас есть данные из множества источников и вы хотите преобразовать их все в формат JSON. Что делать?* Здесь проявляются чудеса командлета `ConvertTo-Json` — он способен преобразовать любой объект PowerShell в **JSON**. 

```powershell
Import-Csv .\user.csv -Delimiter ';'
```

Чтобы выполнить преобразование, нужно передать полученный вывод в `ConvertTo-Json`

```powershell
Import-Csv .\user.csv -Delimiter ';' | ConvertTo-Json
```

Параметр `Compress` урезает количество выходных данных и удаляет все потенциально нежелательные разрывы строк

```powershell
Import-Csv .\user.csv -Delimiter ';' | ConvertTo-Json -Compress
```

Атрибут всегда будет ключом узла, а его значение — значением узла.

## XML
**XML** (*англ. eXtensible Markup Language*) — расширяемый язык разметки, предназначенный для хранения и передачи данных.

[Дока XML](https://doka.guide/tools/xml/?ysclid=loy8geluno795571080)

```powershell
$x = [xml](Get-Content .\msxml.xml)
$x.catalog.book

select-xml -Xml $x -XPath "//book/title" | ForEach-Object {$_.ToString()}
```