# Урок 10. Сигналы Linux

[На главную](/mdk0401.github.io)

## Введение
На данном этапе освоения bash у вас вполне могут возникнуть вопросы о том, как управлять работающими скриптами, как автоматизировать их запуск.

До сих пор мы вводили имена скриптов в командную строку и нажимали Enter, что приводило к немедленному запуску программ, но это — не единственный способ вызова сценариев. Этот урок о том как скрипт может работать с сигналами Linux, о различных подходах к запуску скриптов и управлению ими во время работы.


## Сигналы 
**Сигналы** — это числовые сообщения, которые посылаются запущенным приложениям операционной системой, другими приложениями или пользователем. Сигналы, как правило, ожидают от приложения какой-то определённой реакции, например «корректно завершить работу», «приостановить работу» или «умри!». 

> [!NOTE]
> Ядро Linux посылает процессам сигналы о событиях, на которые им нужно реагировать. Скрипты должны надежно обрабатывать сигналы, "очищать" и производить освобождение ресурсов , даже если вы нажмете ```Ctrl+C```. 

**Сигналы** — это короткие, быстрые односторонние сообщения, отправляемые процессам, сценариями, программами и демонами. **Они сообщают процессу о том, что произошло.** Возможно, пользователь нажал ```Ctrl+C```, или приложение могло попытаться записать в память, к которой у него нет доступа.

Если автор процесса ожидал, что ему может быть отправлен определенный сигнал, он может написать в программе или сценарии подпрограмму(функцию) для обработки этого сигнала. Такая процедура называется **обработчиком сигнала**. Он ловит или перехватывает сигнал и выполняет какое-то действие в ответ на него.

Linux использует множество сигналов, но с точки зрения сценариев существует лишь небольшое подмножество сигналов, которые могут вас заинтересовать. В частности, в нетривиальных сценариях сигналы, сообщающие сценарий для завершения работы должен быть перехвачен (где это возможно) и выполнено корректное завершение работы.

> [!NOTE]
> Сценариям, которые создают временные файлы или открывают порты брандмауэра, можно дать возможность удалить временные файлы или закрыть порты до их закрытия. Если сценарий просто умирает в момент получения сигнала, ваш компьютер может остаться в непредсказуемом состоянии.

## Список сигналов
В Linux используется 64 сигнала. Список можно посмотреть в терминале командой ```kill```

```bash
kill -l
```

![Список сигналов в Linux](sig_list.JPG)

Хотя наш пронумерованный список заканчивается на 64, на самом деле сигналов 62. Сигналы 32 и 33 отсутствуют. Они не реализованы в Linux. Они были заменены функциями компилятора ```gcc``` для обработки потоков в реальном времени. Все, от сигнала 34, ```SIGRTMIN```, до сигнала 64, ```SIGRTMAX```, являются сигналами реального времени.

Вот список наиболее часто используемых, которые наверняка пригодятся при разработке сценариев командной строки

 + Сигнал ```SIGHUP``` (номер 1) изначально был предназначен для того, чтобы информировать программу о потере связи с управляющим терминалом. Этот сигнал посылается процессам и в случае закрытия виртуальных терминалов, которые используются на современных системах вместо аппаратных терминалов. Обычным действием по умолчанию для ```SIGHUP``` является перечитывание конфигурации без остановки(Закрытие терминала).

+ Сигнал ```SIGINT``` (номер 2) посылается процессу, если пользователь терминала дал команду прервать процесс (обычно это сочетание клавиш ```Ctrl+C```).

+ Сигнал ```SIGQUIT``` (номер 3) посылается процессу, если пользователь терминала дал команду остановить процесс комбинацией «quit» (обычно это сочетание клавиш ```Ctrl+\```). Этот сигнал также указывает, что система должна выполнить дамп памяти для процесса.

+ Сигнал ```SIGKILL``` (номер 9) завершает работу программы. Программа не может ни обработать, ни игнорировать этот сигнал.

+ Сигнал ```SIGPIPE``` (номер 13) посылается процессу при записи в соединение (pipe, socket) при отсутствии или обрыве соединения с другой (читающей) стороной.

+ Сигнал ```SIGTERM``` (номер 15) вызывает «вежливое» завершение программы. Получив этот сигнал, программа может выполнить необходимые перед завершением операции (например, высвободить занятые ресурсы). Получение ```SIGTERM``` свидетельствует не об ошибке в программе, а о желании ОС или пользователя завершить ее.

+ Сигнал ```SIGCONT``` (номер 18) возобновляет выполнение процесса, остановленного сигналом ```SIGSTOP``` или сигналом ```SIGTSTP```.

+ Сигнал ```SIGSTOP``` (номер 19) приостанавливает выполнение процесса. Как и ```SIGKILL```, этот сигнал невозможно перехватить или игнорировать.

+ Сигнал ```SIGTSTP``` (номер 20) приостанавливает процесс по команде пользователя (обычно это сочетание клавиш ```Ctrl+Z```). Для возобновления выполнения используется сигнал ```SIGCONT```.

> [!IMPORTANT]
> На сигналы можно ссылаться по имени, номеру или сокращенному имени. Их сокращенное имя — это просто их имя с удаленным начальным *SIG*.

Если оболочка bash получает сигнал ```SIGHUP``` когда вы закрываете терминал, она завершает работу. Перед выходом она отправляет сигнал ```SIGHUP``` всем запущенным в ней процессам, включая выполняющиеся скрипты.

Сигнал ```SIGINT``` приводит к временной остановке работы. Ядро Linux перестаёт выделять оболочке процессорное время. Когда это происходит, оболочка уведомляет процессы, отправляя им сигнал ```SIGINT```.

**Bash-скрипты не контролируют эти сигналы, но они могут распознавать их и выполнять некие команды для подготовки скрипта к последствиям, вызываемым сигналами.**

## Посылка сигналов 
Сигналы посылаются:

+ из терминала, нажатием специальных клавиш или комбинаций (например, нажатие ```Ctrl-C``` генерирует ```SIGINT```, ```Ctrl-\``` - ```SIGQUIT```, а ```Ctrl-Z``` - ```SIGTSTP```);

+ ядром системы:
    - при возникновении аппаратных исключений (недопустимых инструкций, нарушениях при обращении в память, системных сбоях и т. п.);
    - ошибочных системных вызовах;
    - для информирования о событиях ввода-вывода;
    
+ одним процессом другому (или самому себе), с помощью системного вызова ```kill()```, в том числе: из shell, утилитой ```/bin/kill```.

**Сигналы не могут быть посланы завершившемуся процессу, находящемуся в состоянии «зомби».**

## Отправка сигналов скриптам
Оболочка bash позволяет отправлять скриптам сигналы, пользуясь комбинациями клавиш на клавиатуре, хотя обычно для отправки сигналов приложениям используется программа ```kill```.

> [!NOTE]
> Например ```Ctrl+C``` или ```Ctrl+Z```. 

Это оказывается очень кстати если нужно **временно остановить выполняющийся скрипт или завершить его работу**.

### Завершение работы процесса
Комбинация клавиш ```Ctrl+C``` генерирует сигнал ```SIGINT``` и отправляет его всем процессам, выполняющимся в оболочке, что приводит к завершению их работы.

Выполним в оболочке такую команду

```bash
sleep 0.00005d
```

После этого завершим её работу 
комбинацией клавиш ```Ctrl+C```.

