# Урок 07. Циклы
[На главную](/mdk0401.github.io)

**Цикл в программировании** — это управляющая конструкция, которая заставляет какой-то блок кода выполняться несколько раз.

В Bash имеется 4 вида циклов:

+ цикл for;
+ цикл while;
+ цикл until;
+ цикл select(в следующих лекциях).

Цикл ```for`` удобен для перебора конечных множеств (списков слов; простых массивов, которые могут быть преобразованы в списки слов; ассоциативных массивов через их ключи).

Циклы ```while``` и ```until``` используются, когда число итераций нам заранее не известно, но известно условие остановки, которое должно рано или поздно выполниться от действий в теле цикла. Как частный случай, эти циклы могут быть использованы для создания бесконечного цикла.

Цикл ```select``` является не портируемым циклом, который облегчает создание меню выбора в интерактивных сценариях. В принципе, он может не использоваться, так как его функциональность можно запрограммировать с помощью ```while``` и ```until```, но в нем уже реализованы многие проверки, что немного экономит время.

Вместе с циклами идут два управляющих слова: 
+ break 
+ и continue. 

Команда ```break``` позволяет вам прервать цикл в текущей итерации в некоторой точке цикла и перенести точку следования программы на строку, следующую за циклом. 

Команда ```continue``` позволяет прервать исполнение текущей итерации и перенести точку исполнения в начало цикла. В Bash у этих команд нет аргументов.

## FOR
Задокументированный синтаксис цикла имеет следующий вид

```
for <NAME> in <WORDS>; do
  <LIST>
done
```

Здесь ```<NAME>``` имя переменной, которая работает как ссылка на текущий элемент из списка слов ```<WORDS>```. После каждого прогона список смещается на одну позицию влево, удаляя предыдущий элемент. Цикл будет продолжаться до тех пор, пока в результате смещения обнаруживаются новые слова.

Обратите внимание, что переменная будет создана циклом в глобальной области видимости, т.е. потенциально она может затереть уже существующую переменную. 

**Списком слов является строка из слов, разделенных (по умолчанию) пробелом и/или символом табуляции и/или символом переноса строки, причем символы-разделители должны быть частью этого списка.** Вообще список слов разделяется по символам, записанным в переменной окружения ```IFS```. Временно редактируя эту переменную, вы можете управлять процедурой получения списка слов.

> [!WARNING]
> Список не обязательно должен быть заранее известен: его может подготавливать некоторая команда.

```bash
for word in "word1" "word2" "word3" "word4"
do
    echo $word
done
# for word in word1 word2 word3 word3
```

```bash
for var in 1 2 3 4 5
do
    echo $var
done
```

```bash
# попробуй поставить всё в кавычки
for var in six seven eight nine ten
do
    echo "$count - $var"
    (( count++ ))
done;
```

## Перебор массивов
Так как массивы имеют конечный размер, их перебор циклом for является наилучшим решением. Перебор простых массивов может быть реализован через индексы, обычно, когда вам не нужно перебирать их целиком.

```bash
arr=(Таким образом дальнейшее развитие различных форм деятельности обеспечивает широкому кругу участие в формировании систем массового участия.)

# замените @ на *
for var in "${arr[@]}" 
do
    # len=${#var}
    len=`echo -n $var | wc -m`  # -n убирает \n

    if [ $len -ge 9 ]
    then
        echo "$len - $var"
    fi
done
```

```bash
declare -a fruits=('apple' 'pear' 'banana' 'Peruvian cherry' 'orange' 'grapes' 'pineapple')

# Перебор массива целиком, но с применением индексов
for index in ${!fruits[@]}; do
    echo ${fruits[$index]}
done
```

Массив можно преобразовать в список двумя способами: ```${fruits[@]}``` и ```${fruits[*]}```. Без кавычек разницы нет никакой, но вариант ```"${fruits[@]}"``` позволяет учесть пробельные символы внутри самих элементов массива. Так, в нашем примере в массиве с фруктами без кавычек, элемент *'Peruvian cherry'* разделился бы на два, что неправильно. Вариант ```${fruits[*]}``` вернет массив одной строкой без разделения.

Для перебора ассоциативных массивов необходимо преобразовать в список их ключи.

```bash
declare -A mesg=(
	[date]=$(date --rfc-3339='date')
	[message]="Hello."
	[author]="John Smith"
	[additional comment]="urgent"
)

for key in "${!mesg[@]}"
do
     echo -e "Key: $key \t Value=${mesg[$key]}"
done
```

Опять же, чтобы не было пробелы в именах ключей необходимо использовать вариант с кавычками ```"${!mesg[@]}"```, иначе в списке окажется два несуществующих ключа. На практике обычно пробелы в ключах не используют, но лучше лишний раз перестраховаться.


