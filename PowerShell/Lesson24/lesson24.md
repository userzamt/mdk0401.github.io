# Урок 24. Обработка ошибок

[На главную](/mdk0401.github.io)

При применении сценариев для решения реальных администраторских задач (например, для управления учетными записями пользователей, резервного копирования информации на серверах, анализа журналов событий с целью выявления попыток несанкционированного доступа в систему и т. п.) весьма актуальной становится обработка возможных ошибок или исключительных ситуаций. Нужно быть уверенным, что определенная задача выполнена полностью, а в случае возникновения ошибки проанализировать и устранить ее. Язык PowerShell предлагает несколько механизмов обработки ошибок.

Кроме того, в оболочке PowerShell имеются средства отладки сценариев, помогающие находить ошибки в программном коде, а также анализировать ход выполнения сценариев и состояние системы при этом.

## Обработка ошибок
Возникновение ошибки при выполнении команды PowerShell приводит не только к выводу текстовых сообщений на экран, а еще и к автоматическому созданию настоящего **объекта**, в свойствах которого содержится полная информация о данной ошибке. Один аспект обработки ошибок в PowerShell отличает эту систему от других языков программирования: ошибки здесь могут быть *"критическими"* (прерывающими выполнение команды) и *"некритическими"* (при их возникновении выполнение команды продолжается). Это связано с тем, что для обработки объектов в PowerShell используется модель конвейера команд. 

При возникновении *"некритической"* ошибки информация о ней записывается в соответствующий объект, а текущая команда **продолжает обрабатывать** поступающие к ней по конвейеру объекты. 

Подобная ошибка может возникнуть, например, при копировании с помощью командлета множества файлов, один из которых оказался занят другим приложением. В таком случае логично продолжить копирование остальных файлов. 

Если же выполняется какая-то важная и логически неделимая операция, то может иметь смысл остановить ее после возникновения первой ошибки (тогда подобная ошибка будет *"критической"*). 

**При этом одна и та же ошибка в одной ситуации должна считаться *"критической"*, а в другой — *"некритической"*.** 

Поэтому в PowerShell встроен механизм, позволяющий явно задавать эти типы для ошибок. При возникновении *"некритических"* ошибок информация о них помещается в объекты типа `ErrorRecord`, которые записываются в специальный поток ошибок.

```powershell
Get-Service bits,foo,lanmanserver
```

## Объект ErrorRecord и поток ошибок
В PowerShell информация о возникающих ошибках записывается в поток ошибок, который по умолчанию отображается на экране

> [!WARNING]
> Пример с ошибкой

```powershell
Get-Item "bar"
```

Поток ошибок можно перенаправить в текстовый файл с помощью специального оператора `2>`

```powershell
Get-Item "bar" 2> err.log
```

Объект `ErrorRecord`, создающийся при возникновении ошибки, можно сохранить в переменной. Для этого используется оператор `2>&1`, который перенаправляет поток ошибок в стандартный выходной поток.

```powershell
$err = Get-Item "bar" 2>&1
```

Проверим с помощью командлета `Get-Member`, какие свойства имеет объект типа `ErrorRecord`

```powershell
$err | Get-Member
```

Проверим содержимое переменной `$err` 

```powershell
$err | Format-List -Force
```

Итак, мы изучили структуру объекта `ErrorRecord`. Напомним, что получили мы этот объект путем **перенаправления потока ошибок** в стандартный выходной поток в одной конкретной команде. Понятно, что для каждой выполняемой команды повторять эти манипуляции мы не сможем (ведь стандартный выходной поток может понадобиться для других целей) — значит, необходим более удобный механизм, позволяющий определять, возникла ли ошибка, и обращаться к объекту `ErrorRecord`, который соответствует той или иной ошибке. Подобные механизмы реализованы в PowerShell с помощью нескольких специальных переменных и параметров.

## Сохранение объектов, соответствующих ошибкам 
В PowerShell имеется специальная переменная `$Error`, которая содержит коллекцию (массив) объектов `ErrorRecord`, соответствующих ошибкам, возникавшим **в текущем сеансе работы**. Максимальное количество элементов в данной коллекции задается значением переменной `$MaximumErrorCount` (по умолчанию это 256)

```powershell
$MaximumErrorCount
```

После заполнения массива `$Error` объекты для вновь возникающих ошибок будут заменять объекты, соответствующие старым ошибкам. Возникновение каждой новой ошибки приводит к смещению элементов в массиве `$Error`: объект для последней ошибки хранится в первом элементе (`$Error[0]`), объект для предыдущей ошибки — во втором элементе (`$Error[1]`) и т. д.

```powershell
$Error
```

Естественно, мы можем обращаться ко всем свойствам объекта `ErrorRecord`

```powershell
$Error[0].Exception
```

Для перехвата ошибок определенной команды без перенаправления ошибок в стандартный выходной поток можно воспользоваться стандартным параметром `-ErrorVariable`, который определен во всех командах PowerShell. 

```powershell
Get-Item bar, foo -ErrorVariable myErrors
```

При выполнении данной команды возникают две ошибки, то есть переменная `$myErrors` должна быть массивом, содержащим два объекта `ErrorRecord`.

```powershell
$myErrors.Count
```

При указании параметра `-ErrorVariable` сообщения о возникающих ошибках по-прежнему выводятся на экран. Для подавления этих сообщений нужно перенаправить поток ошибок на пустое устройство `$Null`

```powershell
Get-Item bar, foo -ErrorVariable myErrors 2> $null
```

При этом объекты, соответствующие ошибкам, записываются и в переменную `$myErrors`.

## Мониторинг возникновения ошибок 
При интерактивной работе в оболочке PowerShell мы узнаем о возникновении ошибки по сообщению на экране. После этого мы можем проанализировать объект `$Error[0]` и узнать всю информацию об ошибке. *Но как узнать о возникновении ошибки внутри сценария?* 

В PowerShell имеется логическая переменная `$?`, которая равна `$True`, если последняя выполняемая операция завершена успешно, и `$False`, если во время выполнения последней операции возникли какие-либо ошибки. 

> [!NOTE]
> Например, если выполнить командлет `Get-Item` для заведомо существующего каталога, то значение переменной `$?` будет равно `$True`

```powershell
$?
```

Для внешних команд Windows и сценариев PowerShell определено понятие кода возврата (для сценариев PowerShell этот код можно установить с помощью инструкции `Exit`). В операционной системе код возврата последней команды доступен через переменную среды `%ERRORLEVEL%`; в оболочке PowerShell данный код возврата хранится в специальной переменной `$LASTEXITCODE`. При этом, если код возврата **равен нулю**, то переменной `$?` присваивается значение `$True`. Если же код возврата **не равен нулю**, то считается, что при выполнении данной команды произошла ошибка, и переменной `$?` присваивается значение `$False`.

## Режимы обработок ошибок 
В начале мы говорили о том, что ошибки в PowerShell делятся на *"критические"* (прерывающие выполнение команды) и *"некритические"* (при их возникновении выполнение команды продолжается). При этом в зависимости от ситуации *"некритические"* ошибки иногда может потребоваться рассматривать как *"критические"* и наоборот. Подобное изменение типа ошибок реализовано в PowerShell с помощью  различных режимов обработки ошибок.

Чтобы превратить ошибку в завершающую, нужно использовать параметр `ErrorAction`. Он является общим параметром — то есть встроенным в каждый командлет PowerShell. Параметр `ErrorAction` определяет, что нужно сделать, если рассматриваемый командлет столкнется с незавершающей ошибкой.

У этого параметра есть пять основных значений:

+ `Continue`: выводит сообщение об ошибке и продолжает выполнение командлета. Является значением по умолчанию.

+ `Ignore`: продолжает выполнение командлета без вывода ошибки и ее записи в переменную `$Error`.

+ `Inquire`: выводит сообщение об ошибке и предлагает пользователю ввести данные перед продолжением.

+ `SilentlyContinue`: продолжает выполнение командлета без вывода сообщения об ошибке, но записывает ее в переменную `$Error`.

+ `Stop`: выводит сообщение об ошибке и останавливает выполнение командлета.

```powershell
Resolve-DnsName -Name 10.207.106.12 -Type PTR -ErrorAction SilentlyContinue

Get-Item foo -ErrorAction Ignore
```

Параметр `ErrorAction` полезен для управления поведением ошибок в каждом конкретном случае. Чтобы изменить метод, с помощью которого PowerShell обрабатывает все незавершающие ошибки, можно использовать `$ErrorActionPreference` — встроенную переменную, которая управляет поведением этих ошибок, настроенным по умолчанию. У переменной `$ErrorActionPreference` по умолчанию установлено значение `Continue`. 

```powershell
$ErrorActionPreference

$ErrorActionPreference = Stop
```

> [!IMPORTANT]
> Имейте в виду, что параметр `ErrorAction` имеет приоритет над значением `$ErrorActionPreference`.

## Обработка критических ошибок
Чтобы предотвратить остановку программы из-за исключений, их сперва нужно захватить. Это можно сделать с помощью конструкции `try/catch/finally`.

```powershell
try {
    # initial code
} catch {
    # code that runs if terminating error found
} finally {
    # code that runs at the end
}
```

Блок `try` содержит исходный код, который надо запустить. Если возникает исключение, PowerShell перенаправляет поток выполнения в блок `catch`. Независимо от того, выполнится ли код в блоке `catch`, код в блоке `finally` будет выполняться всегда. 

Обратите внимание, что блок `finally` является необязательным, в отличие от `try` или `catch`. 

```powershell
$folderPath = '.\bogusFolder'

try {
    $files = Get-ChildItem -Path $folderPath –ErrorAction Stop

    $files.foreach({
        $fileText = Get-Content $files
        $fileText[0]
    })
} catch {
    $_.Exception.Message
}
```

Когда завершающая ошибка захватывается в блок `catch`, объект этой ошибки сохраняется в переменной `$_`.

Передача значения `Stop` в параметр `ErrorAction` гарантирует, что отсутствующая папка вернет завершающую ошибку, которая будет захвачена. *Но что произойдет, если вы столкнетесь с ошибкой при попытке использовать функцию Get-Content для доступа к файлу?*

```powershell
$filePath = '.\bogusFile.txt'

try {
    Get-Content $filePath
} catch {
    Write-Host "We found an error"
}
```

Выводится сообщение об ошибке от PowerShell, а не то, которое написано в блоке `catch`. Это связано с тем, что функция `Get-Content` возвращает **незавершающую ошибку**, если элемент не найден, а конструкция `try/catch` ловит только **завершающие**. Это означает, что код будет работать так, как задумано, — любые ошибки доступа к файлам не остановят выполнение программы, а просто вернутся в консоль. 

Обратите внимание, что в этом коде мы не использовали блок `finally`. Он отлично подходит для размещения кода, который выполняет задачи чистки вроде отключения открытых подключений к базе данных, очистки сеансов удаленно- го взаимодействия PowerShell и т. д. В данном случае нам это не было нужно.