# Урок 08. Параметры и ключи командной строки
[На главную](/mdk0401.github.io)

Наиболее распространённый способ передачи данных сценариям заключается в использовании параметров командной строки. Вызвав сценарий с параметрами, мы передаём ему некую информацию, с которой он может работать. 

```bash
$ ./myfunc.sh 10 20
```

В данном примере сценарию передано два параметра — ```10``` и ```20```. Всё это хорошо, но как прочесть
данные в скрипте?

## Чтение параметров командной строки
Оболочка bash назначает специальным переменным, называемым позиционными параметрами, введённые при вызове скрипта параметры командной строки:

+ ```$0``` — имя скрипта.
+ ```$1``` — первый параметр.
+ ```$2``` — второй параметр — и так далее, вплоть до переменной ```$9```, в которую попадает девятый
параметр.

> [!IMPORTANT]
> Если скрипту надо больше девяти параметров, при обращении к ним номер в имени переменной надо заключать в фигурные скобки
> ```${10}```

```bash
# запустите скрипт с указанием параметров(через пробелы) после его имени
echo $0
echo $1
echo $2 
```

```bash
if [ -n "$1" ] && [ -n "$2" ]
then
    # summ=$[ $1 + $2 ] # old 
    summ=$(( $1 + $2 )) # new version 

    echo $summ
else
    exit 1  # exit with error
fi
```

Параметры командной строки не обязательно должны быть числами. Сценариям можно передавать и строки.

```bash
# изменим вывод результат из прошлого примера
echo "$1 + $2 = $summ"
```

Что если параметр содержит пробелы, а нам надо обрабатывать его как самостоятельный фрагмент данных? **Необходимо использовать кавычки**.

```bash
$ ./myfunc.sh "Иванов Иван Иванович"
# $1 = "Иванов Иван Иванович"
```

## Работа с параметрами
В скрипте можно подсчитать количество переданных ему параметров. Оболочка bash предоставляет для этого специальную переменную. А именно, переменная ```$#``` содержит количество параметров, переданных сценарию при вызове.

```bash
$ ./myfunc.sh Иванов Иван Иванович
```

```bash
echo "Количество переданных параметров - $#"
```
Эта переменная даёт необычный способ получения последнего из переданных скрипту параметров, не требующий знания их количества.

```bash
echo "Последний параметр имеет значение - ${!#}"
```

В некоторых случаях нужно захватить все параметры, переданные скрипту. Для этого можно воспользоваться переменными ```$*``` и ```$@```. Обе они содержат все параметры командной строки, что делает возможным доступ к тому, что передано сценарию, без использования позиционных
параметров.

Переменная ```$*``` содержит все параметры, введённые в командной строке, в виде единого «слова».

В переменной ```$@``` параметры разбиты на отдельные «слова». Эти параметры можно перебирать в циклах.

```bash
list=$@
str=$*

echo $list
echo $str

echo "For \$@"
for var in "$@"
do
    echo -e "\t$var"
done

echo "For \$*"
for var in "$*"
do
    echo -e "\t$var"
done
```

Переменная ```$*``` содержит все переданные скрипту параметры как единый фрагмент данных, в то время как в переменной ```$@``` они представлены самостоятельными значениями. Какой именно переменной воспользоваться — зависит от того, что именно нужно в конкретном сценарии.


## ```shift```
На операционных системах семейства Unix (Linux, FreeBSD и т. п.) в bash работает команда ```shift```. Когда она выполняется, происходит сдвиг влево позиционных параметров скрипта (т. е. аргументов командной строки, переданных в скрипт). Каждый из параметров помещается в более младшую относительно текущей позицию.

```bash
shift [n]
```

Когда вы запускаете ```shift n```, текущие позиционные параметры сдвигаются влево n раз. Позиционный параметр x получает значение позиционного параметра x+n. Если параметр x+n не существует, то параметр x становится неустановленным.

Если величина сдвига ```n``` для команды ```shift``` не указана, то применяется значение по умолчанию 1. Таким образом, команды shift 1 и shift без аргумента делают одно и то же.

Если параметр сдвигается в позицию, которая меньше 1, то он выбрасывается, т. е. его значение теряется. Так что, к примеру, команда ```shift``` будет всегда выбрасывать предыдущее значение ```$1```, и ```shift 2``` всегда выбросит предыдущие значения ```$1``` и ```$2```.

Специальный позиционный параметр ```$0``` исключается из операций ```shift```, и он всегда остается доступным, на него команда ```shift``` не влияет.

```bash
len=$#

# for ((i=0; i < $#; i++))
# for ((i=0, len=$#; i < $#; i++))
for ((i=0; i <= len; i++))
do
    echo -e "\nIteration $i"
    echo "--------------------"
    echo "\$1 = $1"
    shift
    sleep 1
done
```

> [!WARNING]
> Используя команду ```shift```, помните о том, что при каждом её вызове значение переменной ```$1``` безвозвратно теряется.

## ```case```
Инструкции ```case``` и ```select``` технически не являются циклами, поскольку не предусматривают многократное исполнение блока кода. Однако, они, как и циклы, управляют ходом исполнения программы, в зависимости от начальных или конечных условий.

```bash
case "$variable" in

    "$condition1" )
        command1
        ...
        commandN
    ;;

    "$condition2" )
        command1
        ...
        commandN
     ;;

esac
```

Конструкция ```case``` эквивалентна конструкции switch в языке C/C++. Она позволяет выполнять тот или иной участок кода, в зависимости от результатов проверки условий. Она является, своего рода, краткой формой записи большого количества операторов if/then/else и может быть неплохим инструментом при создании разного рода **меню**.

**Важно**

+ Заключать переменные в кавычки необязательно, поскольку здесь не производится разбиения на отдельные слова.

+ Каждая строка с условием должна завершаться правой (закрывающей) круглой скобкой ```)```.

+ Каждый блок команд, отрабатывающих по заданному условию, должен завершаться двумя символами точка-с-запятой ```;;```.

+ Блок ``case`` должен завершаться ключевым словом ``esac`` (case записанное в обратном порядке).

```bash
num=$(( $RANDOM % 10 ))

case $num in

    2) 
        echo "Num = 2"
    ;;

    8 ) echo "Octonumber)))";;

    *) echo $num ;;
esac
```

Допускается указывать диапазоны символов в [квадратных скобках]

```bash
key=" "

case "$key" in
  [a-z]) echo "буква в нижнем регистре";;
  [A-Z]) echo "Буква в верхнем регистре";;
  [0-9]   ) echo "Цифра";;
  *       ) echo "Знак пунктуации, пробел или что-то другое";;
```

```bash
echo -n "Хотите поиграть?(Да/Нет): "
read answer

case $answer in 
    Д | Да | д | да | Yes | yes | Y | y )
        echo "Ура!! Мы играем"
    ;;

    Н|Нет|н|нет|No|no|N|n )
        echo "Очень жаль(( До свидания"
    ;;

    *) echo "Мне не понятен Ваш ответ"; echo ; answer="" ;;
esac
```
