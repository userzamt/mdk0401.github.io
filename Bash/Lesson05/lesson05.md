# Урок 05. Массивы
[На главную](/mdk0401.github.io)

**Массив** — структура данных, хранящая набор значений (элементов массива), идентифицируемых по индексу.

Bash поддерживает одномерные типы массивов с числовым индексом и ассоциативные массивы. Для ссылок на числовые массивы используются целые числа, а для ассоциативных ссылок — с помощью строк.

> [!WARNING]
> Нет максимального ограничения на размер массива

В отличие от большинства языков программирования, элементы массива Bash не обязательно должны иметь один и тот же тип данных. Вы можете создать массив, содержащий как строки, так и числа.

> [!WARNING]
> Bash не поддерживает многомерные массивы, и у вас не может быть элементов массива, которые также являются массивами.

## Создание
Массивы в Bash можно инициализировать по-разному.

### Создание массивов с числовой индексацией
Чтобы явно объявить массив, используйте встроенную команду declare:

```bash
declare -a array_name
```

Один из способов создать индексированный массив — использовать следующую форму:

```
array_name[index_1]=value_1
array_name[index_2]=value_2
array_name[index_n]=value_n
```

Где *index_\** — положительное целое число.


Массивы не требуют, чтобы последовательность элементов в массиве была непрерывной.

Некоторые элементы массива могут оставаться неинициализированными.
"Дырки" в массиве не являются ошибкой.

```bash
area[11]=23
area[13]=37
area[51]=UFOs

echo -n "area[11] = "
echo ${area[11]}    #  необходимы {фигурные скобки}


echo -n "area[13] = "
echo ${area[13]}

echo "содержимое area[51] = ${area[51]}."
```

Обращение к неинициализированным элементам дает пустую строку.

```bash
echo -n "area[43] = "
echo ${area[43]}        № элемент area[43] - неинициализированн
```

Другой способ создать числовой массив — указать список элементов в круглых скобках, разделенных пустым пространством:

```
array_name=( element_1 element_2 element_N )
```

Когда массив создается с использованием формы выше, индексация начинается с нуля, то есть первый элемент имеет индекс 0.

```bash
area2=( ноль один два три четыре )

echo "area2[0] = ${area2[0]}"
#  индексация начинается с нуля (первый элемент массива имеет индекс [0], а не [1]).

echo "area2[1] = ${area2[1]}"
# [1] - второй элемент массива.
```

### Создание ассоциативных массивов

В отличие от числовых индексов, ассоциативные массивы должны быть объявлены до того, как их можно будет использовать.

Чтобы объявить ассоциативный массив, используйте встроенную команду ```declare``` с параметром ```-A``` (верхний регистр)

```
declare -A array_name
```

Ассоциативные массивы можно создавать, используя следующую форму:

```bash
declare -A array_name

array_name[index_foo]=value_foo
array_name[index_bar]=value_bar
array_name[index_xyz]=value_xyz
```

Где ```index_*``` может быть любой строкой.

Вы также можете создать ассоциативный массив, используя форму ниже:

```bash
declare -A array_name

array_name=( 
  [index_foo]=value_foo 
  [index_bar]=value_bar 
  [index_xyz]=value_xyz 
)

# ******************************************
declare -A myarr=(
    [four]=4
    [5]=5
    [" "]=" space "
    [10]="ten"
    [TWO]="TWO"
)

```

## Операции с массивами

### Обращение к элементу массива
На любой элемент можно ссылаться, используя следующий синтаксис:

```bash
${array_name[index]}
```

Синтаксис доступа к элементу массива аналогичен синтаксису большинства языков программирования. Фигурные скобки ```${}``` необходимы, чтобы избежать операторов раскрытия имени файла оболочки.

```bash
declare -a my_array=( "Hydrogen" "Helium" "Lithium" "Beryllium" )

echo ${my_array[1]}     # Helium

echo ${my_array}        # Hydrogen
# массивы указывают на нулевой элемент
```

Если используются ```@``` или ```*``` в качестве индекса, слово расширяется до всех членов массива. 

```bash
declare -a my_array=( "Hydrogen" "Helium" "Lithium" "Beryllium" )

echo "${my_array[@]}" 
# "Hydrogen Helium Lithium Beryllium"
```

> [!IMPORTANT]
> ```*``` возвращает все аргументы в виде одной строки (слова)
> ```@``` то же самое, что и ```*```, но при этом каждый элемент массива представлен как отдельная строка (слово).

```bash
declare -a my_array=( "Hydrogen" "Helium" "Lithium" "Beryllium" )

echo "${my_array[*]}" 
# "Hydrogen" "Helium" "Lithium" "Beryllium"
# cycle FOR
```

### Список ключей
Чтобы распечатать ключи массива, необходимо добавить оператор ```!```  перед именем массива

```bash
${!array_name[index]}
```

Пример:

```bash
declare -a my_array=( "Hydrogen" "Helium" "Lithium" "Beryllium" )

echo "${!my_array[@]}"
# 0 1 2 3

# ****************************
declare -A arr

arr[moth1]=Январь
arr[moth2]=Февраль
arr[moth3]=Март

echo ${!arr[@]} 
# moth3 moth2 moth1
```

### Длина массива
Чтобы получить длину массива, используйте следующую форму

```
${#array_name[@]}
```

Синтаксис такой же, как и при ссылке на все элементы с добавлением символа ```#``` перед именем массива.

```bash
my_array=( "Hydrogen" "Helium" "Lithium" "Beryllium" )

## array Length
echo ${#my_array[@]}        # 4
```

> [!WARNING]
> ```${#array_name}```- это длина (количество символов) первого элемента массива, т.е. ```${array_name[0]}```

```bash
echo ${#my_array}  # 8
# "Hydrogen" = 8 символов
```

### Срез
Иногда необходимо извлечь определенные части массива

```bash
declare -a indexed_array=("Baeldung" "is" "cool" "and" "better" "than" "before")

echo "Offset 1 length 3: ${indexed_array[@]:1:3}"
# Offset 1 length 3: is cool and
```

Эта конструкция принимает *index смещения* и длину.

```
${array[@]:index:len}
```

Если опустить длину получим все элементы массива, начиная со смещения, до конца

```bash
echo "Offset 1 no length: ${indexed_array[@]:1}"
# Offset 1 no length: is cool and better than before
```

Отрицательное смещение считается относительно с конца массива массива.

Обратите также внимание на символ ```<пробел>``` при использовании отрицательных смещений. Если его не использовать, Bash путает его с другой конструкцией(операцией вычитание).

```bash
echo "Offset -1 length 3: ${indexed_array[@]: -4:3}"
# Offset -1 length 3: and better than
```

## Преобразование массивов
В массивах доступа работа с регистром строк и заменой строк, так же как в строках.

```bash
my_array=( "Hydrogen" "Helium" "Lithium" "Beryllium" )

echo ${my_array[@]^^}   # HYDROGEN HELIUM LITHIUM BERYLLIUM
echo ${my_array[@],,}   # hydrogen helium lithium beryllium
echo ${my_array[1],}    # helium

echo ${my_array[@]/i/W} # Hydrogen HelWum LWthium BeryllWum
```

## Удаление

При работе с массивами, некоторые встроенные команды Bash имеют несколько иной смысл. Например, ```unset``` - удаляет отдельные элементы массива, или даже массив целиком.

Команда unset удаляет переменную, фактически устанавливает ее значение в null.

```bash
variable=hello              # Инициализация.
echo "variable = $variable"

unset variable              # Сброс.

# Тот же эффект дает   variable=
echo "(unset) variable = $variable"  # $variable = null.
```

Удаление значений из массива

```bash
my_array=( "Hydrogen" "Helium" "Lithium" "Beryllium" )

unset  my_array[3]
echo "${my_array[@]}"
```

Удаление массива

```bash
unset  my_array
```

## Добавление
Bash позволяет добавлять элементы в массив

```bash
array=(
    filenames
)

echo ${array[@]}      # filenames

array+=(two)
echo ${array[@]}      # filenames two

array+=( $(ls) )      # удобно хранить список файлов
echo ${array[@]}      # filenames two access.log array.sh basic.sh case.sh charcase.sh ...
```

Слияние массивов

```bash
arr1=(1 2 3 4 5 6 7 9 10)
arr2=(one two three four)

arr1+=( ${arr2[@]} )

echo ${arr1[@]}               # 1 2 3 4 5 6 7 9 10 one two three four
echo "Len arr = ${#arr1[@]}"  # 13
```