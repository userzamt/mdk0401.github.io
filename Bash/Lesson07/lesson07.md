# Урок 07. Циклы
[На главную](/mdk0401.github.io)

**Цикл в программировании** — это управляющая конструкция, которая заставляет какой-то блок кода выполняться несколько раз.

В Bash имеется 4 вида циклов:

+ цикл for;
+ цикл while;
+ цикл until;
+ цикл select(в следующих лекциях).

Цикл ```for`` удобен для перебора конечных множеств (списков слов; простых массивов, которые могут быть преобразованы в списки слов; ассоциативных массивов через их ключи).

Циклы ```while``` и ```until``` используются, когда число итераций нам заранее не известно, но известно условие остановки, которое должно рано или поздно выполниться от действий в теле цикла. Как частный случай, эти циклы могут быть использованы для создания бесконечного цикла.

Цикл ```select``` является не портируемым циклом, который облегчает создание меню выбора в интерактивных сценариях. В принципе, он может не использоваться, так как его функциональность можно запрограммировать с помощью ```while``` и ```until```, но в нем уже реализованы многие проверки, что немного экономит время.

Вместе с циклами идут два управляющих слова: 
+ break 
+ и continue. 

Команда ```break``` позволяет вам прервать цикл в текущей итерации в некоторой точке цикла и перенести точку следования программы на строку, следующую за циклом. 

Команда ```continue``` позволяет прервать исполнение текущей итерации и перенести точку исполнения в начало цикла. В Bash у этих команд нет аргументов.

## FOR
Задокументированный синтаксис цикла имеет следующий вид

```
for <NAME> in <WORDS>; do
  <LIST>
done
```

Здесь ```<NAME>``` имя переменной, которая работает как ссылка на текущий элемент из списка слов ```<WORDS>```. После каждого прогона список смещается на одну позицию влево, удаляя предыдущий элемент. Цикл будет продолжаться до тех пор, пока в результате смещения обнаруживаются новые слова.

Обратите внимание, что переменная будет создана циклом в глобальной области видимости, т.е. потенциально она может затереть уже существующую переменную. 

**Списком слов является строка из слов, разделенных (по умолчанию) пробелом и/или символом табуляции и/или символом переноса строки, причем символы-разделители должны быть частью этого списка.** Вообще список слов разделяется по символам, записанным в переменной окружения ```IFS```. Временно редактируя эту переменную, вы можете управлять процедурой получения списка слов.

> [!WARNING]
> Список не обязательно должен быть заранее известен: его может подготавливать некоторая команда.

```bash
for word in "word1" "word2" "word3" "word4"
do
    echo $word
done
# for word in word1 word2 word3 word3
```

```bash
for var in 1 2 3 4 5
do
    echo $var
done
```

```bash
# попробуй поставить всё в кавычки
for var in six seven eight nine ten
do
    echo "$count - $var"
    (( count++ ))
done;
```

## Перебор массивов
Так как массивы имеют конечный размер, их перебор циклом for является наилучшим решением. Перебор простых массивов может быть реализован через индексы, обычно, когда вам не нужно перебирать их целиком.

```bash
arr=(Таким образом дальнейшее развитие различных форм деятельности обеспечивает широкому кругу участие в формировании систем массового участия.)

# замените @ на *
for var in "${arr[@]}" 
do
    # len=${#var}
    len=`echo -n $var | wc -m`  # -n убирает \n

    if [ $len -ge 9 ]
    then
        echo "$len - $var"
    fi
done
```

```bash
declare -a fruits=('apple' 'pear' 'banana' 'Peruvian cherry' 'orange' 'grapes' 'pineapple')

# Перебор массива целиком, но с применением индексов
for index in ${!fruits[@]}; do
    echo ${fruits[$index]}
done
```

Массив можно преобразовать в список двумя способами: ```${fruits[@]}``` и ```${fruits[*]}```. Без кавычек разницы нет никакой, но вариант ```"${fruits[@]}"``` позволяет учесть пробельные символы внутри самих элементов массива. Так, в нашем примере в массиве с фруктами без кавычек, элемент *'Peruvian cherry'* разделился бы на два, что неправильно. Вариант ```${fruits[*]}``` вернет массив одной строкой без разделения.

Для перебора ассоциативных массивов необходимо преобразовать в список их ключи.

```bash
declare -A mesg=(
	[date]=$(date --rfc-3339='date')
	[message]="Hello."
	[author]="John Smith"
	[additional comment]="urgent"
)

for key in "${!mesg[@]}"
do
     echo -e "Key: $key \t Value=${mesg[$key]}"
done
```

Опять же, чтобы не было пробелы в именах ключей необходимо использовать вариант с кавычками ```"${!mesg[@]}"```, иначе в списке окажется два несуществующих ключа. На практике обычно пробелы в ключах не используют, но лучше лишний раз перестраховаться.

## Цикл с заданным числом повторений
Цикл ```for``` может быть использован, чтобы сделать что-нибудь несколько раз подряд. 

Для генерации повторений обычно просто генерируют список из чисел одним из следующих способов.

```bash
for i in {1..80}; do echo -n "#"; done; 
```

```bash
echo -e "\t \e[33m ABC \e[0m"

for ch in {a..z}
do
    echo -ne "\e[31m $ch \t"
done;
```

```bash
for file in file{00..05}.log
do
    touch $file
done;
```

## Инициализация цикла списком, полученным из результатов работы команды
Ещё один способ инициализации цикла ```for``` заключается в передаче ему списка, который является результатом работы некоей команды. Тут используется подстановка команд для их исполнения и
получения результатов их работы.

```bash
file="access.log"

for var in $(cat $file)
do
    echo " $var"
done
# "$(....)"
```

В этом примере задействована команда ```cat```, которая читает содержимое файла. Полученный список значений передаётся в цикл и выводится на экран. 

> [!WARNING]
> Обратите внимание на то, что в файле, к которому происходит обращение, может содержать список слов, разделённых знаками перевода строки, пробелы при этом не используются.

Перебор файлов в папке

```bash
mypath="/cygdrive/c/Users/Ольга/"
res=`ls $mypath`

for item in $res
do
    # full path
    if [ -f $mypath$item ]
    then
        echo "File - $item"
    fi 
done
```

Другой вариант перебора файлов

```bash
for file in /cygdrive/c/Users/Ольга/*
# for file in "$mypath"*
do
    # используем ковычки - имена могут быть с пробелами
    if [ -d "$file" ]
    then
        echo "Directory - $file"
    fi
done
```

## Циклы ```for``` в стиле C
В Bash есть еще один вариант записи цикла ```for```, который он унаследовал от Ksh. Этот стиль используется, чтобы записать инкрементируемую переменную и условие выхода из цикла в одну строку, как это было придумано в языке Си.

Синтаксис описания bash-циклов ```for``` может показаться странным, так как привыкли мы, к такому описанию циклов:

```c
// пример кода на C
for (i = 0; i < 10; i++)
{
    printf(“number is %d\n”, i);
}
```

В bash-скриптах можно использовать циклы ```for```, описание которых выглядит очень похожим на циклы в стиле C, правда, без некоторых отличий тут не обошлось. Схема цикла при подобном подходе выглядит так:

```bash
for (( начальное значение переменной ; условие окончания цикла; изменение переменной ))
```

На bash это можно написать так:

```bash
for (( i=1; i <= 10; i++ ))
do
    echo "number is $i"
done
```

```bash
arr2=()

for ((j=0, len=100;j<len;++j))
do
    arr2+=($RANDOM)
done

echo ${arr2[*]}
```

## Циклы while и until
Циклы ```while``` и ```until``` похожи. Они используются, когда число повторений выражается условием остановки. Базовый синтаксис обоих циклов в целом похож, разница состоит только в интерпретации кода возврата последней команды командного списка условия.

```
[ while | until ] <LIST1> ; do
  <LIST2>
done
```

Цикл ```while``` выполняется (т.е. исполняет командный список ```<LIST2>```) до тех пор, пока последняя команда списка ```<LIST1>``` возвращает нулевой код, т.е. *ИСТИНУ*. Напротив, цикл ```until``` выполняется до тех пор, пока последняя команда списка ```<LIST1>``` возвращает не нулевой код, т.е. *ЛОЖЬ*. Можно использовать такой мнемонический прием: **```while``` повторяет свои действия пока не сломается, а ```until``` — пока не получится**.

Оба цикла возвращают 0, если ни одной итерации не происходило, иначе они возвращают код последней команды списка ```<LIST2>``` последней исполненной итерации.

Исполнением этих циклов часто управляют из ```<LIST2>``` с помощью команд ```continue``` и ```break```.

```bash
arr3=()
count=5     # сколько надо чисел
step=0
min=100     # диапазон 
max=200

while [ ${#arr3[@]} -le $count ]
do
    num=$RANDOM
    if [ $num -ge $min ] && [ $num -le $max ] 
    then
        arr3+=($num)
    else
        echo "Число не подошло. Шаг $step"
        (( step +=1 ))
    fi
done

echo ${arr3[@]}
```

```bash
min=100
max=1000
arr4=()
step=0

start=`date +%H:%M:%S:%N`

while [ $step -lt 30 ]
do
    num=$(( $RANDOM % $max + $min ))
    arr4+=($num)

    step=$(($step+1))
done

echo "Array4 => ${arr4[@]}"
end=`date +%H:%M:%S:%N`
echo -e "$start \t $end"
```

> [!NOTE]
> Обычно придумывать условие в негативном ключе ```until``` сложнее, чем в позитивном для ```while```, поэтому цикл ```until``` встречается реже.

## Цикл в стиле ```do...while```
**В Bash нет цикла в стиле do...while, но его при желании можно эмулировать.**

## Разделители полей
```bash
file="access.log"

for var in $(cat $file)
do
    echo " $var"
done
```

Причина вышеописанной особенности заключается в специальной переменной окружения, которая называется *IFS (Internal Field Separator)* и позволяет указывать разделители полей. По умолчанию оболочка bash считает разделителями полей следующие символы:

+ Пробел
+ Знак табуляции
+ Знак перевода строки

Если bash встречает в данных любой из этих символов, он считает, что перед ним — следующее самостоятельное значение списка.

Для того, чтобы решить проблему, можно временно изменить переменную среды IFS.

Вот как это можно сделать в bash-скрипте, если в качестве разделителя полей нужен только перевод строки:

```bash
IFS=$'\n'
```
После добавления этой команды в bash-скрипт, он будет работать как надо, игнорируя пробелы и знаки табуляции, считая разделителями полей лишь символы перевода строки.

```bash
file="access.log"
IFS=$'\n'

for var in $(cat $file)
do
    echo " $var"
done
```

Разделителями могут быть и другие символы.

```bash
csv="Васильев;Оскар;Богданович;м;7(585)801-94-29 ;1971.01.30;miturria@verizon.net;2017.05.28 00:00:00"
IFS=';'

for i in $csv
do
    echo $i
done
```

В переменной окружения ```$PATH``` пути разделены ```:```. Если в цикле
нужно обрабатывать подобные строки, *IFS* можно настроить

```bash
IFS=':'

for folder in $PATH
do
    for file in $folder/*
    do
        if [ -x "$file" ] && [ -O "$file" ]
        then
            echo $file
        else
            continue
        fi
    done
done
```

## Обработка вывода, выполняемого в цикле
Данные, выводимые в цикле, можно обработать, либо перенаправив вывод, либо передав их в конвейер. Делается это с помощью добавления команд обработки вывода после инструкции ```done```.

Например, вместо того, чтобы показывать на экране то, что выводится в цикле, можно записать всё это
в файл или передать ещё куда-нибудь

```bash
for (( a = 1; a < 10; a++ ))
do
    echo "Number is $a"
    :
done > myfile.txt

echo "finished."
```

Оболочка создаст файл ```myfile.txt``` и перенаправит в этот файл вывод конструкции ```for```. 
