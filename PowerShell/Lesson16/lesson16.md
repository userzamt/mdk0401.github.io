# Урок 16. PowerShell. Типы данных

[На главную](/mdk0401.github.io)

Необходимо рассмотреть четыре основных понятия, связанных с `PowerShell`: переменные, типы данных, объекты и структуры данных. 

Эти понятия фундаментальны практически для каждого языка программирования, но в `PowerShell` есть еще кое-что, отличающее его от других языков: в нем **все является объектом**.

Но перед этим...

## Работают ли знакомые команды?
Все команды, к которым вы привыкли (например, cd, dir и cls), также работают в PowerShell. 

```powershell
dir
ls
```

По сути, эти *«команды»* на самом деле являются не командами, а их псевдонимами, благодаря которым `PowerShell` и понимает эти команды. 

```powershell
cd C:\
Set-Location C:\
```

Узнать какие команды `cmd.exe` работают в `PowerShell` можно с помощью `Get-Alias`

```powershell
Get-Alias
Get-Alias cd
Get-Alias pwd
```

## Типы команд 
В оболочке `cmd.exe` все команды разделялись на внутренние, которые распознавались и выполнялись непосредственно интерпретатором `cmd.exe`, и внешние, которые представляли  собой отдельные исполняемые модули. К внутренним относятся, например, команды `dir` и `copy`, а к внешним — `xcopy` и `more`. Кроме этого, оболочка `cmd.exe` поддерживает сценарии — **командные файлы**. 

В оболочке `PowerShell` поддерживаются команды четырех типов: 
+ командлеты
+ функции
+ сценарии
+ внешние исполняемые файлы.

### Командлеты 
Командлет представляет собой класс .NET, порожденный от базового класса `Cmdlet`. Единый базовый класс `Cmdlet` гарантирует совместимый синтаксис всех командлетов, а также автоматизирует анализ параметров командной строки и описание синтаксиса командлетов, выдаваемое встроенной справкой. 

Командлеты можно считать в определенном смысле аналогом внутренних команд традиционных оболочек, хотя в отличие от внутренних команд новые командлеты могут быть добавлены в систему в любое время.

```powershell
Get-Command
```

### Функции 
Функция — это блок кода на языке `PowerShell`, имеющий название и находящийся в памяти до завершения текущего сеанса командной оболочки. Анализ синтаксиса функции производится только один раз при ее объявлении (при повторном запуске функции подобный анализ не проводится). 

> [!NOTE]
> Более подробно функции разберутся в другой лекции

### Сценарии 
Сценарий представляет собой блок кода на языке `PowerShell`, хранящийся во внешнем файле с расширением `ps1`. Анализ синтаксиса сценария производится при каждом его запуске. Сценарии позволяют работать с `PowerShell` в пакетном режиме, то есть заранее создать файл с нужными командами, определить логику работы с помощью различных управляющих инструкций языка `PowerShell` и пользоваться этим файлом как исполняемым модулем.

Существуют системные политики, ограничивающие выполнение скриптов. Можно проверить текущие параметры политики, введя команду Get-ExecutionPolicy.

```powershell
Get-ExecutionPolicy
```

Результатом будет одно из следующих значений:

+ **Restricted** — выполнение скриптов запрещено. Стандартная конфигурация;
+ **AllSigned** — можно запускать скрипты, подписанные доверенным разработчиком; перед запуском скрипта `PowerShell` запросит у вас подтверждение;
+ **RemoteSigned** — можно запускать собственные скрипты или те, что подписаны доверенным разработчиком;
+ **Unrestricted** — можно запускать любые скрипты.

Для начала работы необходимо изменить настройку политики запуска на RemoteSigned, используя команду `Set-ExecutionPolicy`(в режиме Администратор)

```powershell
Set-ExecutionPolicy RemoteSigned
```

### Внешние исполняемые файлы 
Последний тип команд, запускаемых в `PowerShell`, — внешние исполняемые файлы, которые выполняются операционной системой обычным образом. В частности, из оболочки `PowerShell` можно запускать любые внешние команды интерпретатора `cmd.exe` (например, `xcopy`), просто указывая их имена.

## Диски PowerShell 
Все мы давно привыкли к структуре файловой системы как совокупности вложенных папок (каталогов) и файлов. В операционной системе Windows интерфейс к такой структуре предоставляют Проводник Windows, оболочка `cmd.exe`, а также различные файловые менеджеры сторонних разработчиков. 

В UNIX-системах понятия файлов и папок трактуются более широко, в качестве файлов здесь могут выступать различные компоненты системы (например, аппаратные устройства или сетевые подключения). Такой подход упрощает поиск нужных элементов в операционной системе. Оболочки командной строки или другие утилиты, обращающиеся к файлам в UNIX-системах, могут работать также и с этими компонентами. 

Оболочка `PowerShell` в этом аспекте похожа на UNIX-системы, так как она позволяет просматривать различные хранилища данных и перемещаться по ним с использованием тех же привычных процедур, которые применяются для перемещения по файловой системе. Помимо обычных локальных или сетевых дисков файловой системы (C:, D: и т. д.) оболочка поддерживает специальные (виртуальные) диски `PowerShell`, связанные с хранилищами данных разных типов.

> [!IMPORTANT]
> В отличие от обычных локальных или сетевых дисков файловой системы диски
`PowerShell` доступны только из оболочки `PowerShell`, обратиться к ним из Проводника Windows нельзя. Имена дисков `PowerShell` могут содержать более одного символа. 

```powershell
Get-PSDrive
```

Командлет `Get-PSDrive` для каждого диска сообщает имя провайдера (колонка *Provider*), поддерживающего этот диск. 

```powershell
Set-Location HKLM:\
```

**Провайдер** `PowerShell` — это .NET-приложение, предоставляющее пользователям `PowerShell` доступ к данным из определенного специализированного хранилища в согласованном формате, напоминающем формат обычных дисков файловой системы. Тем самым провайдеры `PowerShell` обеспечивают доступ к данным, к которым трудно обратиться через командную строку иными способами.

| Провайдер | Хранилище данных |
| :--: | :-- |
| **Alias** | Псевдонимы PowerShell |
| **Certificate** | Сертификаты X509 для цифровых подписей |
| **Environment** | Переменные среды Windows |
| **FileSystem** | Диски файловой системы, каталоги и файлы |
| **Function** | Функции PowerShell |
| **Registry** | Реестр Windows |
| **Variable** | Переменные PowerShell |

```powershell
Get-PSProvider
```

## Вычисление выражений 
Кроме выполнения команд, в `PowerShell` можно вычислять выражения, то есть пользоваться оболочкой как калькулятором (в оболочке `cmd.exe` эта возможность отсутствовала).

```powershell
32-58*(67-9)
25 % 9
10 / 3
```

В `PowerShell` можно выполнять и более сложные вычисления, включающие в себя различные математические функции. Для этого используются методы .NET-класса `System.Math`.

```powershell
[System.Math]::Pow(2,4)
[System.Math]::Sqrt(144)
[System.Math]::PI
```

## Переменные
**Переменная** — это место для хранения значений.

Все переменные в `PowerShell` начинаются со знака доллара `$`, который сообщает `PowerShell`, что  вызывается именно переменная, а не командлет, функция, файл сценария или исполняемый файл.

```powershell
$MaximumHistoryCount
```

`$MaximumHistoryCount` — это встроенная переменная, которая определяет максимальное количество команд, которое `PowerShell` сохраняет в своей истории. 

```powershell
$MaximumHistoryCount = 400
```

### Пользовательские переменные
```powershell
$color
```

> [!WARNING]
> Если после выполнения не получили сообщение об ошибке, и в консоли не выводится никаких данных, необходимо выполнить следующую команду, чтобы включить строгий режим: `Set-StrictMode -Version Latest`
> Включение этого режима заставляет `PowerShell` выдавать информацию об ошибке, если вы нарушаете правила написания кода. Например, строгий режим вынуждает `PowerShell` возвращать ошибку при обращении к несуществующему свойству объекта или к не определенной ранее переменной. Считается, что лучше включать этот режим при написании сценариев, поскольку так вы будете писать более чистый и предсказуемый код.

```powershell
$color = 'red'
```

Когда используется знак равенства для определения переменной, выполняется то же самое, что и команда `Set-Variable`. 

```powershell
Set-Variable -Name var -Value 45.56768
```

Аналогично, когда вы вводите в консоли переменную и получаете значение, вы делаете то же, что и с помощью команды `Get-Variable`. 

```powershell
Get-Variable -Name color
```

Эта команда так же выводит список всех переменных, в настоящее время находящихся
в памяти.

```powershell
Get-Variable
```

### Переменные оболочки `PowerShell`
**Переменные оболочки** — это набор переменных, которые создаются, объявляются оболочкой `PowerShell` и присутствуют по умолчанию в каждом сеансе работы. 

Переменные оболочки сохраняются в течение всего сеанса и доступны всем командам, сценариям и приложениям, которые выполняются в данном сеансе. 

Поддерживаются два вида переменных оболочки
+ **Автоматические переменные.** В этих переменных хранятся параметры состояния оболочки `PowerShell`. Автоматические переменные сохраняются и динамически изменяются самой системой. Пользователи не могут (и не должны) изменять значения этих переменных. 

```powershell
$PID
```

+ **Переменные настроек**. В этих переменных хранятся настройки активного пользователя. Эти переменные создаются оболочкой PowerShell и заполняются значениями по умолчанию. Пользователи могут изменять значения этих переменных. Например, переменная `$MaximumHistoryCount` определяет максимальное число записей в журнале сеанса. 

```powershell
Get-Variable
```

Переменными оболочки можно пользоваться так же, как и другими видами
переменных.

```powershell
ls $PSHOME 
```

```powershell
Get-Process -Id $PID
```

Переменная `$null` немного странная: она ничего не представляет. Присвоение значения `$null` другой переменной позволяет создать эту переменную, но не присваивает ей реального значения

```powershell
$color
$test = $null
Get-Variable test
```

Еще одна часто используемая встроенная переменная — `$LASTEXITCODE`. `PowerShell` позволяет запускать внешние исполняемые приложения вроде старого доброго `ping.exe`. Когда внешние приложения завершают работу, они заканчиваются с кодом выхода, или кодом возврата, который имеет определенное значение. Как правило, 0 означает удачный исход, а что-либо другое — сбой или аномалию. Для приложения `ping.exe` ответ 0 означает, что связь с узлом удалось успешно проверить, а 1 — что ничего не получилось.

```powershell
PING.EXE 77.88.8.7
$LASTEXITCODE
```

## Переменные среды Windows 
Кроме собственных переменных, оболочка `PowerShell` позволяет работать и с переменными среды (или переменными окружения) Windows, каждая из которых хранится в оперативной памяти в течение всего сеанса работы операционной системы, имеет свое уникальное имя, а ее значением является строка. Стандартные переменные среды автоматически инициализируются в процессе загрузки операционной системы. К таким переменным относятся, например, `WINDIR`, которая определяет расположение каталога Windows, `TEMP`, которая определяет путь к каталогу для хранения временных файлов Windows или `PATH`, в которой хранится системный путь (путь поиска), то есть список каталогов, в которых система должна искать выполняемые файлы или файлы совместного доступа (например, динамические библиотеки).

В оболочке `PowerShell` доступ к переменным среды можно получить через виртуальный диск `Env:`

```powershell
ls env:
dir Env:
Get-ChildItem Env:
```

Для получения значения определенной переменной среды нужно перед ее именем указать префикс `env:`. Например, следующая команда выведет на экран путь к корневому каталогу операционной системы, который хранится в переменной среды `SystemRoot`

```powershell
$env:SystemRoot
```

## Типы данных
Переменные в `PowerShell` бывают разных типов. В `PowerShell` есть несколько типов данных, к которым относятся логические значения, строки и целые числа, и что можно изменять тип данных переменной без получения сообщений об ошибках.

```powershell
$foo = 1 
$foo = 'one' 
$foo = $true
```

Дело в том, что `PowerShell` может определять типы данных, основываясь на переданном значении переменной. 

PowerShell использует типы данных Microsoft .NET Framework. Рассмотрим основные:

| Тип | .NET класс | Описание |
| :--: | :--: | :-- |
| [string] | System.String	| Строка
| [char] | System.Char	| Символ
| [bool] | System.Boolean	| Булево. Может иметь значение $true или $false.
| [int] | System.Int32	| 32-разрядное целое число
| [long] | System.Int64	| 64-разрядное целое число
| [decimal] | System.Decimal	| 128 битное десятичное число. Буква d на конце числа обязательна
| [double] | System.Double	| 8-байтное десятичное число с плавающей точкой
| [single] | System.Single	| 32 битное число с плавающей точкой
| [DateTime] | System.DateTime | Переменная даты и времени.
| [array] | System.Object[]	| Массив. 
| [hashtable] | System.Collections.Hashtable 	| Хеш-таблицы. Различие между хэш-таблицами и массивами в том, что в массивах используются индексы, а в хэш-таблице именованные ключи. 

Для проверки типа переменной можно воспользоваться  методом `GetType`

```powershell
$foo.GetType()
(10).GetType().ToString()
$color.GetType().FullName
```

### Логические значения 
Практически в каждом языке программирования есть логические значения `True` или `False` (1 или 0, истина или ложь).

> [!NOTE]
> Логические значения используются для обозначения некоторых двоичных вещей, например, включен свет или нет. 

В PowerShell логические значения называются `bool` и представлены двумя встроенными переменными — `$true` и `$false`. Эти встроенные переменные неизменны и жестко закодированы в PowerShell.

```powershell
$true
$isOn = $false
```

### Целые числа и числа с плавающей точкой
Язык `PowerShell` поддерживает все основные числовые типы платформы .NET: `System.Int32`, `System.Int64`, `System.Double`. При этом явно задавать тип чисел нет необходимости — **система сама выбирает подходящий тип для указываемого вами числа**.

```powershell
$i = 234324
$i.GetType()
```

По умолчанию `PowerShell` хранит целые числа в виде 32-разрядного типа `Int32` со знаком. Количество разрядов определяет, насколько большое (или маленькое) число может хранить переменная. В нашем случае это любое значение в диапазоне от –2 147 483 648 до 2 147 483 647. Для чисел вне этого диапазона можно использовать 64-битный знаковый тип `Int64`, который имеет диапазон от –9 223 372 036 854 775 808 до 9 223 372 036 854 775 807

```powershell
$i = 234324325252352345
$i.GetType()
```

```powershell
$i = 23.14
$i.GetType()
```

Теперь `PowerShell` считает переменную как тип `Double`. Это связано с тем, что `PowerShell` изменяет тип переменной в зависимости от ее значения. Однако можно обрабатывать переменную как имеющую строго определенный тип, преобразовав ее с помощью синтаксиса `[Int32]` перед именем переменной

```powershell
[Int32]$i
$i
```

Тип переменной так же можно назначить вручную

```powershell
[Int32]$num = 12
$num = 21312414124124124124
$num = 2.71
$num
```

### Строки
Все символьные строки в `PowerShell` являются объектами типа `System.String` и представляют собой последовательность 32-битовых символов в кодировке *Unicode*. Длина строк не ограничена, **содержимое строк нельзя изменять** (можно только копировать).

Строки могут задаваться последовательностью символов, заключенных в одинарные или двойные кавычки

```powershell
'Строка в одинарных кавычках' 
"Строка в двойных кавычках"
```

Строки могут содержать любые символы (в том числе символы разрыва строки и возврата каретки), кроме соответствующего одиночного закрывающего символа (одинарной или двойной кавычки). Строка в одинарных кавычках может содержать двойные кавычки и наоборот

```powershell
'Строка в "одинарных" кавычках' 
"Строка в 'двойных' кавычках" 
```

Если внутри строки нужно поместить символ, ограничивающий данную строку (то есть одинарную или двойную кавычку), то нужно написать этот символ два раза подряд

```powershell
'Строка в ''одинарных кавычках' 
"Строка в ""двойных кавычках" 
```

Строки в двойных кавычках являются **расширяемыми**. Это означает, что если внутри строки в двойных кавычках встречается имя переменной или другое выражение, которое может быть вычислено, то в данную строку подставляется значение данной переменной или результат вычисления выражения. 

```powershell
$a=123 
"$a равно $a" 
```

При необходимости можно отключить расширение определенной переменной внутри строки в двойных кавычках. Для этого перед знаком `$` этой переменной нужно указать символ обратного апострофа **\`**

```powershell
"`$a равно $a"
```

Символы, имеющие специальное значение, вставляются в строки в двойных кавычках с помощью escape-последовательностей, которые в `PowerShell` начинаются с символа обратного апострофа **\`**

| Переменная | Описание |
| :--: | :-- |
| `n | Разрыв строки |
| `r | Возврат каретки |
| `t | Горизонтальная табуляция |
| `a | Звуковой сигнал |
| `b | Забой (backspace) |
| `' | Одинарная кавычка |
| `" | Двойная кавычка |
| `0 | Пустой символ (null) |
| `` | Обратный апостроф |


> [!NOTE]
> В других языках программирования типа C, C#, JScript или Perl для выделения специальных символов (escape-последовательностей) используется обратная косая черта (например, `\n` или `\t`). Разработчики оболочки `PowerShell` приняли решение ввести другой символ для escape-последовательностей, чтобы избежать проблем при использовании символа `\` в качестве разделителя компонентов пути в файловой системе Windows и других пространствах имен `PowerShell`.

```powershell
"hello `n`t wotld"
```

Кроме переменных в расширяемых строках могут указываться так называемые **подвыражения** (*subexpression*) — ограниченные символами `$(…)` фрагменты кода на языке `PowerShell`, которые в строках заменяются на результаты вычисления этих фрагментов.

```powershell
"Площадь круга равна $([System.Math]::PI * [System.Math]::Pow(5,2))"
```

В `PowerShell` наряду с обычными строками в одинарных и двойных кавычках поддерживаются так называемые **автономные строки** (также известные под именем строк типа *"here-string"*). Подобные строки обычно используются для вставки в сценарий больших блоков текста или при генерации текстовой информации для других программ и имеют следующий формат:

```powershell
@<кавычка><разрыв_строки>блок текста<разрыв_строки><кавычка>@ 
```

Кавычки могут быть как одинарными, так и двойными, при этом смысл их остается тем же, что и для обычных строк: переменные и подвыражения, стоящие внутри двойных кавычек, заменяются их значениями, а стоящие внутри одинарных кавычек остаются неизменными. 

```powershell
$str = @"
>> Hello world!!!
>> Hi!!
>> Bay Bay
>> "@
PS C:\Users\root> $str
```

### Объекты 
В `PowerShell` всё является объектом. С технической точки зрения объект — это отдельный экземпляр определенного шаблона, который называется **классом**. Класс определяет, что именно объект содержит внутри себя. 

Класс объекта определяет его **методы**, то есть действия, которые можно производить с этим объектом. Другими словами, методы — это то, что объект умеет. 

> [!NOTE]
> Например, у объекта списка может быть метод `sort()`, который сортирует список при вызове. 

Аналогично, класс объекта определяет его **атрибуты**, то есть переменные объекта.

**Атрибуты** — это вся информация об объекте. Если говорить о списках, то у вас может быть атрибут `length`, в котором хранится количество элементов в списке.

Чтобы просмотреть атрибуты объекта, воспользуйтесь командой `Select-Object` и параметром `Property`. 

```powershell
Select-Object -InputObject $color -Property *
```

Чтобы увидеть все методы и атрибуты строкового объекта, необходимо воспользоваться командлетом `Get-Member`. С его помощью можно быстро вывести список всех свойств и методов конкретного объекта, которые вместе называются **элементами объекта.**

```powershell
Get-Member -InputObject $color
```

Для анализа структуры объекта, возвращаемого определенной командой, проще всего направить этот объект по конвейеру на командлет `Get-Member`

```powershell
Get-Process | Get-Member
```

В результате на экран мы видим, какой .NET-тип имеют объекты, возвращаемые в ходе работы исследуемого командлета, а также полный список элементов объекта. При этом на экран выводится очень много элементов разных типов (имена и псевдоним свойств, имена методов и т. д.), и такой длинный список становится неудобно просматривать. 

Командлет `Get-Member` имеет параметр `-MemberType`, позволяющий перечислить только элементы объекта определенного типа. 

> [!NOTE]
> Например, для вывода только элементов объекта, являющихся свойствами этого объекта, используется параметр `-MemberType` со значением `Property`

```powershell
Get-Member -InputObject $color -MemberType Properties
Get-Process | Get-Member -MemberType Properties
```

## Массивы
Для создания и инициализации массива можно просто присвоить значения его элементам. Значения, добавляемые в массив, разделяются запятой и отделяются от имени переменной (имени массива) оператором присваивания

```powershell
$num = 1,2,3,4
```

Чтобы получить доступ к элементу в массиве, нужно указать имя массива, за которым следует пара квадратных скобок `[]`, где указывается индекс нужного элемента. Как и в случае со строковыми символами, нумерация начинается с 0, поэтому у первого элемента индекс 0, у второго 1 и т. д. В `PowerShell` при использовании индекса `–1` возвращается последний элемент

```powershell
$num[$num.Length-1]
```

Если вы попытаетесь указать индекс, которого нет в массиве, `PowerShell` выдаст ошибку

```powershell
$num[8]
```

Можно также создать и инициализировать массив, используя оператор диапазона `..`. 

```powershell
$num = 90..100
```

Чтобы получить доступ к нескольким элементам в массиве одновременно, так же можно использовать оператор диапазона `..` между двумя числами. При его использовании `PowerShell` вернет эти два числа и все, что находятся между ними

```powershell
$num[3..7]
```

Для изменения элемента массива нужно присвоить новое значение элементу с соответствующим индексом

```powershell
$num[0] = 3.14
$num[1] = 22312312423423421242
$num[2] = "Hello, world"
```

Последний пример показывает, что по умолчанию массивы `PowerShell` могут содержать элементы разных типов, то есть являются **полиморфными**. 

```powershell
$num.GetType()
```

Можно создать массив с жестко заданным типом, то есть такой массив, который содержит элементы только одного типа. Для этого, как и в случае с обычными скалярными переменными, необходимо указать нужный тип в квадратных скобках перед именем переменной

```powershell
[Int32[]]$num = 12..18
```

Если попытаться записать в данный массив значение, которое нельзя преобразовать к целому типу, то возникнет ошибка.

Добавление элементов в массив происходит с помощью оператора **конкатенации** `+` или `+=`.

```powershell
$num += 89, 888
```

Следует иметь в виду, что обычный оператор присваивания `=` действует на массивы **по ссылке**. Например, создадим массив *$a* из двух элементов и при- своим этот массив переменной 

```powershell
$a=1,2
$b=$a
$b
```

Теперь изменим значение первого элемента массива *$a* и посмотрим, что произойдет с массивом *$b*:

```powershell
$a[0]="Новое значение"
$b
```
