# Урок 12. sed и обработка текстов

[На главную](/mdk0401.github.io)

**Sed** (от англ. Stream EDitor) — консольная утилита для редактирования текстовых потоков.

Sed неинтерактивный строчный редактор, который принимает текст либо с устройства `stdin`, либо из текстового файла, выполняет некоторые операции над строками и затем выводит результат на устройство `stdout` или в файл. 

Как правило, в сценариях, `sed` используется в конвейерной обработке данных, совместно с другими командами и утилитами.

```bash
sed OPTIONS... [SCRIPT] [INPUTFILE...]
```

Утилиту `sed` называют **потоковым текстовым редактором**. В интерактивных текстовых редакторах, наподобие `nano`, с текстами работают, используя клавиатуру, редактируя файлы, добавляя, удаляя или изменяя тексты. `Sed` позволяет редактировать потоки данных, основываясь на заданных разработчиком наборах правил. 

## Отличие от других редакторов
Раньше текстовые файлы просматривались/обрабатывались построчно, т.е. пользователь, работая на терминале, не видел содержимого целиком, и строка за строкой делал свои изменения. С другой стороны, текст мог поступать на терминал порциями и получался тот же эффект. Во всех этих случаях поступающий текст образует поток символов (*stream*).

Команда `Sed` позволяет определить некоторые правила обработки (написать микропрограмму обработки) для каждой строки в потоке, и в этом собственно ее основная функция. Правила обработки составляется на внутреннем языке `Sed`, который объявляет специальные команды по типу заменить, удалить, подставить и т.п. Составляя из этих команд комбинации, можно писать очень сложные процедуры обработки, которые покрывают большую часть потребностей, встречающихся на практике. 

> [!IMPORTANT]
> У языка `Sed` есть недостаток в том, что он не такой очевидный и иногда сложный, и не посвященному пользователю он будет не понятен.

К типичным задачам `Sed` можно отнести следующие:

+ Вывод исходного файла фрагментами;

+ Замена подстрок в файле по регулярным выражениям;

+ Удаление/Вставка/Изменение фрагментов исходного текста файла по некоторым правилам, в частности, Sed довольно часто используют для автоматизированной правки конфигурационных файлов системы.

Более мощной альтернативой `Sed` является консольная утилита `Awk`, смысл которой такой же, но язык написания правил обработки сложнее и богаче. Однако, практика показывает, что сначала нужно попробовать решить задачу с помощью `Sed`, вместо того, чтобы *«стрелять по воробьям из базуки»*. 

## Введение в синтаксис
По умолчанию sed применяет указанные при вызове правила, выраженные в виде набора команд, к `STDIN`. Это позволяет передавать данные непосредственно `sed`.

```bash
echo "This is a test" | sed 's/test/another test/'
```

В данном случае `sed` заменяет слово *«test»* в строке, переданной для обработки, словами *«another test»*. Для оформления правила обработки текста, заключённого в кавычки, используются прямые слэши. В нашем случае применена команда вида `s/pattern1/pattern2/`. 

Буква *«s»* — это сокращение слова *«substitute»*, то есть — перед нами команда замены. `Sed`, выполняя эту команду, просмотрит переданный текст и заменит найденные в нём фрагменты (о том — какие именно, поговорим ниже), соответствующие `pattern1`, на `pattern2`.

Выше приведён примитивный пример использования `sed`, нужный для того, чтобы ввести вас в курс дела. На самом деле, `sed` можно применять в гораздо более сложных сценариях обработки текстов, например — для работы с файлами.

```bash
sed 's/test/another test' ./myfile
```

Здесь применён тот же подход, который использовался выше, но теперь `sed` обрабатывает текст, хранящийся в файле. При этом, если файл достаточно велик, можно заметить, что `sed` обрабатывает данные порциями и выводит то, что обработано, на экран, не дожидаясь обработки всего файла.

**`Sed` не меняет данные в обрабатываемом файле.** Редактор читает файл, обрабатывает прочитанное, и отправляет то, что получилось, в `STDOUT`. 

При необходимости вывод `sed` можно перенаправить в файл, возможно — перезаписать старый файл.

## Базовый вызов
Утилита `Sed` в базовом виде выглядит примерно так

```bash
sed 'pattern' file1 file2 .... fileN
```

В данном случае правила выполнятся для каждого переданного файла. Если вы не передадите ни одного файла, то утилита перейдет **в интерактивный режим** и будет применять правила выборки для всего, что напишет пользователь в консоль. 

> [!NOTE]
> Интерактивный режим полезен при отладке, если планируется использовать `Sed` в сценарии.

Вообще утилита `Sed` ждет данные в свой `STDIN` поток, т.е. в командной оболочке данные для `Sed` можно передавать через конвейеры и/или дескрипторы

```bash
# Передача данных через конвейер
echo "Text fragment" | sed 'p'

# Передача данных через STDIN (первый вариант)
sed 'p' <<EOF
Text fragment
EOF

# Передача данных через STDIN (второй вариант)
sed 'p' <<< "Text fragment"

# Передача данных через дескриптор (первый вариант)
sed 'p' < file.txt
# аналогично
sed 'p' file.txt
```
> [!WARNING]
> Если `Sed` было передано больше одного файла за один раз, то по умолчанию идет обработка их конкатенации (то есть одного большого потока). Чтобы отменить это поведение и обрабатывать файлы по отдельности, используйте опцию `-s` или `--separate`. 

Sed обрабатывает каждую строку в три шага:

1. Сначала помещает входящую строку в буфер, называемый *pattern space*.

1. Применяет к строке все инструкции. Все это делается в одном буфере *pattern space*.

1. Печатает полученный результат из буфера в свой `STDOUT`.

### Устройство команд
В языке `Sed` можно выделить следующие смысловые части:

+ **Адресация конкретной строки**. Позволяет выбирать из потока только отдельно указанные строки, либо строки, которые соответствуют регулярному выражению.

+ **Диапазон**. Диапазон указывает `Sed` какие строки нужно выбирать перед обработкой. В `Sed` есть несколько способов указать диапазон: можно указать выбираемые строки через числа, а можно через регулярные выражения. Если диапазон никак не указан явно, то `Sed` обрабатывает весь поток целиком.

+ **Команда**. Собственно сама команда, которая исполняется над диапазоном. Команды могут быть сгруппированы через блок. Внутри блока команды отделяются точкой с запятой `;`.

```bash
### Одна команда
<команда>

# Пример
sed -n 'p' test.txt

### Одна команда с диапазоном, на который она направлена
<адресация или диапазон> <команда>

# Пример
sed -n '1 p' test.txt   # адресация первой строки
sed -n '2,8 p' test.txt   # числовой диапазон

# Обратите внимание, что диапазон прикрепляется только к следом идущей команде.
sed -n '1 p ; p' test.txt
# В предыдущем примере две команды разделены ';'. Адресация относится только к первой команде 'p', но не второй.
# Так как для  второй печати диапазон не указан явно, то по умолчанию она будет печатать весь поток.
# Микропрограмма напечатает сначала первую строку, а потом напечатает все строки фрагмента.

### Блок
# Чтобы отнести адресацию или диапазон к нескольким командам, вы должны объединить их в блок через фигурные скобки.

<адресация или диапазон> { <команда1> ; <команда2> ...; <командаN> } 

# Примеры
sed -n '1 { p ; p }' test.txt   # Напечатать два раза первую строку
sed -n '1,3 { p ; p }' test.txt # Напечатать два раза первые три строки

# Как и простые команды, блоки разделяются ;. Если перед блоком стоит адресация или диапазон, то он относится только к
# следующему за ним блоку.

sed -n '1,3 { p ; p } ; 1,2 { p ; p } ; {p ; p}' test.txt
```

> [!NOTE]
> Пробелы в общем случае между отдельными частями не нужны, так как все команды и синтаксические якоря состоят из одного символа, однако пробелы повышают удобочитаемость кода. 

## Выполнение наборов команд
Для выполнения нескольких действий с данными, используйте ключ `-e` при вызове `sed`. 


```bash
sed -e 's/This/That/; s/test/another test/' ./myfile
```

Для ввода нескольких шаблонов обработки текста при вызове `sed`, можно, после ввода первой одиночной кавычки, нажать `Enter`, после чего вводить каждое правило с новой строки, не забыв о закрывающей кавычке

```bash
$ sed -e '
> s/This/That/
> s/test/another test/' ./myfile
```

## Чтение команд из файла
Если имеется множество команд sed, с помощью которых надо обработать текст, обычно удобнее всего предварительно записать их в файл. Для того, чтобы указать `sed` файл, содержащий команды, используют ключ `-f`

Вот пример файла с командами:
```
s/This/That/
s/test/another test/
```

Вызовем `sed`, передав редактору файл с командами и файл для обработки:

```bash
sed -f mycommands myfile
```

Результат при вызове такой команды аналогичен тому, который получался в предыдущих примерах.

## Флаги команды замены
Команда замены нормально обрабатывает файл, состоящий из нескольких строк, но заменяются только первые вхождения искомого фрагмента текста в каждой строке.

```bash
sed 's/test/another test/' myfile
```

Для того, чтобы заменить все вхождения шаблона, нужно использовать соответствующий флаг.

```bash
s/pattern/replacement/flags
```

Выполнение этой команды можно модифицировать несколькими способами:

+ При передаче `номера` учитывается порядковый номер вхождения шаблона в строку, заменено будет именно это вхождение.

+ Флаг `g` указывает на то, что нужно обработать все вхождения шаблона, имеющиеся в строке.

+ Флаг `p` указывает на то, что нужно вывести содержимое исходной строки.

+ Флаг вида `w file` указывает команде на то, что нужно записать результаты обработки текста в файл.

Рассмотрим использование первого варианта команды замены, с указанием позиции заменяемого вхождения искомого фрагмента:

```bash
sed 's/test/another test/2' myfile
```

Тут мы указали, в качестве флага замены, число 2. Это привело к тому, что было заменено лишь второе вхождение искомого шаблона в каждой строке. 

```bash
sed 's/test/another test/g' myfile
```

Как видно из результатов вывода, такая команда заменила все вхождения шаблона в тексте.

Флаг команды замены `p` позволяет выводить строки, в которых найдены совпадения, при этом ключ `-n`, указанный при вызове `sed`, подавляет обычный вывод:

```bash
sed -n 's/test/another test/p' myfile
```

Как результат, при запуске sed в такой конфигурации на экран выводятся лишь строки, в которых найден заданный фрагмент текста.

Воспользуемся флагом `w`, который позволяет сохранить результаты обработки текста в файл

```bash
sed 's/test/another test/w output' myfile
```

В ходе работы команды данные выводятся в `STDOUT`, при этом обработанные строки записываются в файл, имя которого указано после `w`.

## Разделители
Иногда в шаблоне или отдельной части встречается символ, который используется в разделителе. В этом случае вам нужно просто экранировать этот символ, чтобы `Sed` смог определить границу части команды. Но когда таких символов много, большое количество экранирующих символов делает конструкцию нечитаемой. В этом случае разумно просто сменить разделитель.

```bash
# В следующем примере в заменяемом пути используется большое число слешей, как разделителей пути,
# которые требуется экранировать. Обратите внимание, как сложно читать такое выражение.
$ sed 's/SUBST/program\/lib\/module\/lib.so/' <<< "/usr/lib/SUBST"
/usr/lib/program/lib/module/lib.so

# В данном примере мы можем облегчить себе жизнь, если изменим разделитель, например на символ '|'.
$ sed 's|SUBST|program/lib/module/lib.so|' <<< "/usr/lib/SUBST"
/usr/lib/program/lib/module/lib.so

# или так (разделитель '_')
$ sed 's_SUBST_program/lib/module/lib.so_' <<< "/usr/lib/SUBST"
/usr/lib/program/lib/module/lib.so
```

## Выбор фрагментов текста для обработки
В некоторых случаях с помощью `sed` надо обработать лишь какую-то часть текста — некую конкретную строку или группу строк. 

Для достижения такой цели можно воспользоваться двумя подходами:

+ Задать ограничение на номера обрабатываемых строк.

+ Указать фильтр, соответствующие которому строки нужно обработать.

Рассмотрим первый подход. Тут допустимо два варианта. Первый, рассмотренный ниже, предусматривает указание номера одной строки, которую нужно обработать

```bash
sed '2s/test/another test/' myfile
```

Второй вариант — диапазон строк:

```bash
sed '2,3s/test/another test/' myfile
```

Кроме того, можно вызвать команду замены так, чтобы файл был обработан начиная с некоей строки и до конца

```bash
sed '2,$s/test/another test/' myfile
```

Для того, чтобы обрабатывать с помощью команды замены только строки, соответствующие заданному фильтру, команду надо вызвать так

```bash
sed '/likegeeks/s/bash/csh/' /etc/passwd
```

По аналогии с тем, что было рассмотрено выше, шаблон передаётся перед именем команды `s`.

## Удаление строк
Утилита sed годится не только для замены одних последовательностей символов в строках на другие. С её помощью, а именно, используя команду `d`, можно удалять строки из текстового потока.

```bash
sed '3d' myfile
```

Будет удалена третья строка. Обратите внимание на то, что речь не идёт о файле. Файл останется неизменным, удаление отразится лишь на выводе, который сформирует `sed`.

> [!IMPORTANT]
> Если при вызове команды `d` не указать номер удаляемой строки, удалены будут все строки потока.

Вот как применить команду `d` к диапазону строк
```bash
sed '2,3d' myfile
```

Удалить строк, начиная с заданной — и до конца файла

```bash
sed '3,$d' myfile
```

Строки можно удалять и по шаблону

```bash
sed '/test/d' myfile
```

При вызове `d` можно указывать пару шаблонов — будут удалены строки, в которых встретится шаблон, и те строки, которые находятся между ними:

```bash
sed '/second/,/fourth/d' myfile
```

## Вставка текста в поток
С помощью `sed` можно вставлять данные в текстовый поток, используя команды `i` и `a`:

+ Команда `i` добавляет новую строку перед заданной.

+ Команда `a` добавляет новую строку после заданной.

Рассмотрим пример использования команды `i`

```bash
echo "Another test" | sed 'i\First test'
```

Теперь взглянем на команду `a`

```bash
echo "Another test" | sed 'a\Last test'
```

Как видно, эти команды добавляют текст до или после данных из потока. Что если надо добавить строку где-нибудь посередине?

Тут поможет указание номера опорной строки в потоке, или шаблона. **Учтите, что адресация строк в виде диапазона тут не подойдёт.** Вызовем команду `i`, указав номер строки, перед которой надо вставить новую строку

```bash
sed '2i\This is the inserted line.' myfile
```

Проделаем то же самое с командой `a`

```bash
sed '2a\This is the appended line.' myfile
```

Обратите внимание на разницу в работе команд `i` и `a`. Первая вставляет новую строку до указанной, вторая — после.

## Замена строк
Команда `c` позволяет изменить содержимое целой строки текста в потоке данных. При её вызове нужно указать номер строки, вместо которой в поток надо добавить новые данные

```bash
sed '3c\This is a modified line.' myfile
```

Если воспользоваться при вызове команды шаблоном в виде обычного текста или регулярного выражения, заменены будут все соответствующие шаблону строки:

```bash
sed '/This is/c This is a changed line of text.' myfile
```

## Замена символов
Команда `y` заменить любые символы из шаблона `pattern1` на соответствующие символы из `pattern2`

```bash
sed '/y/pattern1/pattern2/' files
```

Команда `y` работает с отдельными символами, заменяя их в соответствии с переданными ей при вызове данными


```bash
sed 'y/123/567/' myfile
# 1 -> 5
# 2 -> 6
# 3 -> 7
```

> [!IMPORTANT]
> Используя эту команду, нужно учесть, что она применяется ко всему текстовому потоку, ограничить её конкретными вхождениями символов нельзя.

## Вывод номеров строк
Если вызвать `sed`, использовав команду `=`, утилита выведет номера строк в потоке данных

```bash
sed '=' myfile
```

> [!NOTE]
> Потоковый редактор выведет номера строк перед их содержимым.

Если передать этой команде шаблон и воспользоваться ключом `sed -n`, выведены будут только номера строк

```bash
sed -n '/test/=' myfile
```

## Чтение данных для вставки из файла
В качестве источника данных можно воспользоваться и файлом. Для этого служит команда `r`, которая позволяет вставлять в поток данные из указанного файла. При её вызове можно указать номер строки, после которой надо вставить содержимое файла, или шаблон.

```bash
sed '3r newfile' myfile
```

Содержимое файла `newfile` будет вставлено после третьей строки файла `myfile`.

```bash
sed '/test/r newfile' myfile
```

В этом примере содержимое файла будет вставлено после каждой строки, соответствующей шаблону.
